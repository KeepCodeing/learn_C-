# C++笔记

> *2023年3月3日 17点12分*
>
> 不知是生不逢时还是时运不济，总之打算转行了。在BOSS直聘之类的平台海投了1k份简历，没有任何回应（实际上是有个面试的，然而太拉跨不谈)。
>
> 人或许总是不想跳出舒适区的，本Five也是如此。学C++？那前端不白学了？而且现在都三月份了，四月份之前找不到工作好像很危险？
>
> 各种理由和拖延，终于还是在今天深感无奈，破防了w...对比室友投两天三四场面试，工作室后端同学更大的投递量还是0进展，似乎再这样下去我也会是一样的结局。
>
> 实际上转行的起因并不止是前端嗯投没机会，还有一部分是自己觉得前端技术难度就那样，底层搬砖可能才是常态。
>
> 学习曲度平滑，培训班、应届生大量选择，三年经验当一年用，似乎被淘汰或者原地踏步才是真实写照。
>
> C++在自己印象里则更多是一个喜闻乐见的方向：掉头发、难度大、没人学..既然如此为什么不去学前后端呢？几年前做出的决定现在又要推翻，而且是在这种时间点...但稍微了解后C++确实是一个不错的选择。
>
> 竞争少，技术更迭慢，难度大但企业愿意培养...
>
> 另外对应这个时间点，想到了一句鸡汤：种一棵树最好的时间是十年前，其次是现在。人生何处不青山，趁着还有机会多尝试尝试也未必是一种冒险...

## C++就业课

> 看着是个14年的老视频了，不过语言方面可能无所谓，所以就快速看完再说了...

### 常识

区别于之前JS，C++这玩意是写了半年左右的算法的，所以有些语法就是常识。本着全面的角度，这里也记下来。

1. 命名空间，`using namespace std;`实际上表示下面的所有代码都默认带上`std::`这个命名空间。这算是C++的一种”模块化“，在多人开发时可以避免函数名冲突导致的错误。这里**`::`就是域控制符**。
2. `class`用来代替`struct`，但**内部成员默认为`private`**。类似Java，不手动指定就是私有成员变量。
3. 函数声明在C++中更加严谨，函数实现和声明的**参数列表、返回值类型必须完全对应**，否则报错。
4. 更严格的指针类型约束，**不同类型的指针想要进行赋值，必须进行类型转换**。例如`void *p; int * a = (void * p)`，这里如果不强转就会报错。
5. **C++中给指针分配内存，使用`new`而不是`malloc`**。`int *p = new int(10); delete p;`，这是C++推荐的标准写法，它的作用和`int *p = (int *)malloc(sizeof(int)); free(p);`是一样的，但无需引用头文件，还能直接指定初始值。此外`new`和`malloc`虽然作用一样，但本质上是有很大区别的，`new`需要使用`delete`释放内存；`malloc`使用`free`，二者不可混用。
6. `int *arr = new int[10]; delete []arr;`，使用`new`来分配数组空间（动态数组长度）。
7. C++中的**引用变量并不是表示地址，而是表示变量别名**。这也就是说引用和指针实际上没什么关系。`int a = 10; int &c = a;`，这里`c`就是`a`的别名，操作`c`相当于操作`a`（地址相同），所以就可以`void swap(int &a, int &b)`真的能直接改变`int a; int b`的值这种效果。因为这个特性，**引用变量必须要有一个明确的值**。
8. 引用区别与指针，假设我们有两个栈空间`main和func`，在`main`的栈空间中存放变量，通过引用传递给`func`，那`func`是不会产生新的栈空间的。也就是说**引用变量从头到尾都是直接操作本身，不会产生第二份**。另外如果我们只是想把变量传进去使用，那可以用`const &`来将其变为只读的。
9. 对象里的`this`：这个`this`不是JS里的`this`，因此不存在各种奇奇怪怪的指向什么的，它就是一个**指向当前类的指针**（注意是指针），在参数和成员变量重名的时候，就可以用它来明确变量`this->age = age`。

### 杂项

和JS笔记一样，用来记录零碎不成单元的小知识。

1. **`volatile`修饰符**：它的作用是保证被修饰的变量**不被编译器优化**。那什么样的代码会被优化呢？比如`i +=1; i += 2`这种就可能直接被优化成`i += 3`。那为什么需要禁止优化呢？因为在单片机之类的系统中，程序的走向是可能被电路之类的操作影响的。如果因为这种情况导致优化中代码片段的某些条件改变了，就可能发生错误。（或许解释了为什么嵌入式里全用了这个修饰符）
2. **`inline`修饰符**：它表示某个函数是内联函数，内联函数的作用就是**直接把函数调用改成调用函数代码体**，也就是`inline void test() { int i = 1; }`的效果和`int = 1`是一样的，调用时就是去执行这一条语句。当函数体代码量比较少时，这样做能提高运行效率。（或许解释了为什么OI选手喜欢这样写）
3. **缺省参数**：也就是`void test(int a, int b = 10)`这种写法，`b`就是缺省参数。我们调用时不指定值就默认是10。和JS一样，**缺省参数必须放在参数列表中非缺省参数之前**，否则报错。
4. **函数重载**：**函数重载主要是根据参数类型来的，和函数返回值类型无关**。`void a(); void a(int t); void a(char t);`这就是一个重载的关系，`a`函数分别有三个重载，无参、整形参数、字符型参数。但要注意，**如果重载的不同函数调用方式相同（空参函数+剩余参数），就会出错**（重载类型不明确），例如：`void a(); void a(int t = 1);`，这时缺省参数可以不传，直接调用会有两个对应的函数，就会报错。
5. **模板函数**：简单来说就是**使用`template <class T>`这种形式来给函数参数类型指定一个泛型**。`template <class T> T add(T a, T b) { return a + b; }`，但注意，调用时不需要指定泛型类型（毕竟是强类型语言），直接使用就行，C++编译器会把对应的函数生成出一份对应的代码。例如：`add(1, 2)`。与普通函数一样，**模板函数也能重载和使用缺省参数**等。
6. **命名空间和静态变量**：使用`namespace myspace { void func() {} }`，这样就能创建一个命名空间为`myspace`的作用域了。如果我们写成`namespace {}`这种形式，就是一个**匿名的命名空间**，~~所有内部声明的代码都只能在该命名空间内使用，相当于一个和外界隔离的块作用域~~。**匿名的命名空间，相当于没有命名，在程序中可以直接调用，而不需要使用`namespace::`的形式。**`static`关键字也可以限制函数作用域范围，假设我们在`t.cpp`中声明了`static void test() {}`，那这个`test`方法就**只能在`test.cpp`中使用**（因为被提前编译了？）。
7. **指针类成员保护**：一般我们会把类成员变量设置成私有属性，然后使用`getter/setter`间接操作。但如果我们**操作的是一个指针类型，那就要用`const`把`getter`的返回值设置成只读指针了**，否则外界拿到指针地址后还是能直接操作内部成员。
8. **类内部访问外部同名变量**：有时会存在类**内部变量和外部变量同名的情况。这时优先会调用类内部的变量**，如果**想要访问外部变量，使用`::outside`就行了，这个`::`是一个关键字**，方法或者变量都适用。
9. **`struct`和`class`的区别**：在C++中，`struct`用起来和类基本一样，只不过**`struct`内部指明权限操作符，默认为`public`，而`class`默认为`private`**。
10. **C++中的类和变量作用域**：很简单，**类内部的变量只能通过类来访问**。但区别于C语言，**C++中定义普通外部变量建议在`cpp`文件中定义，这是因为C++中`.h`文件可能会被多处引用，就会照成重复定义**。在`cpp`中定义的变量如果想要引用，可以**使用C的`extern`关键字来完成**，`extern int i`就表示引用外部声明的`i`变量。
11. **构造函数初始化成员变量**：C++中可以用`constroctor(int a) { age = a; }`这种方式初始化，也可以用一种叫做**初始化成员列表**的方式对成员变量进行初始化，它的语法是`constructor(): age(10)`，这种方式**还能对`const`修饰的变量进行初始化**，而普通赋值是不行的。注意，**只读成员变量和引用成员变量必须用初始化成员列表的方式进行初始化**，因为它们没法赋值。
12. **C/C++混合编译**：如果我们**混用了C和C++代码，并且C++代码引用了C代码**，就可能出现**C代码中函数找不到**的问题。原因是**C++进行编译时会改变函数名**，因为C++存在**重载机制**，所以即使是看起来函数名相同的重载函数，在编译后的代码中也是不同名的（使用`nm output.exe`可以查看编译后的代码）。那如何解决呢？很简单，**在C语言代码中使用`extern "C" { void hello() {} } `这种方式**（注意这里有个前提，就是**只能在`.h`中使用，不能在`.c`中使用**，因为这是**C++特有的关键字**）告诉编译器这是一个C语言代码就行了，这样编译后就不会改变函数名了。
13. **命名空间的重命名**：如果某个命名空间过长，**可以使用`namespace h = hello`这种方式重命名**。
14. **访问全局变量**，**`::var`可以用来访问全局变量**，这点在8中已经记录了。

### 类的基础知识

其实杂项和常识里就写了一部分，现在发现视频基本是在讲类的内容了，所以单独开一节更好。

#### 类的声明和实现

在C++中，如何对类进行声明以及内部成员定义：

我们可以采用**分文件的方式对类进行编写**，这样项目结构更清晰，代码易于维护。一般使用`.h`对类进行声明，`.cpp`进行实现，当然也可以直接在类里面实现方法。

还是惯例的，直接看代码：

`main.cpp`，主文件，调用`man`类。

```cpp
#include <iostream>
#include "man.h"

using namespace std;

int main() {
    // 在栈里给m分配空间
	man m = man();
    // 使用new在堆里分配空间，需要手动释放空间（调用析构函数）
    man *m2 = new man;
    delete m2;
	m.say_hello();
	m.set_age(10);
    
    // 类本质上是个结构体，所以调用sizeof获得的结果和结构体是一样的
    cout << sizeof(man) << endl;
	
	cout << m.get_age() << endl;
	return 0;
}
```

`man.h`，对`man`类进行声明。

```cpp
#ifndef MAN_H
#define MAN_H

#include <string>
#include <iostream>
using namespace std;

class man {
	private:
		int age;
		string name;
	
	public:
    	// 构造函数，对象实例化时自动调用，不写编译器会自动生成一个
    	man();
    	// 析构函数，对象在内存中被回收时自动调用，不写同样会自动生成，一般用来释放类成员占用内存空间
    	~man();
    
		int get_age();
		
		string get_name();
		
		void set_age(int a);
		
		void set_name(string n);
		
    	// 直接在类中对方法进行编写
		void say_hello() {
			cout << "hello hello how low" << endl;
		}
};
#endif
```

`man.cpp`，对`man`类进行实现。

```cpp
#include "man.h"

// 下面这些简单代码都很可能被编译器优化成inline形式
int man::get_age() {
	return age;
}

string man::get_name() {
	return name;
}

void man::set_age(int a) {
	age = a;
}

void man::set_name(string n) {
	name = n;
}
```

#### 类成员列表初始化

我们在使用普通构造函数时，可以用`demo(int x, int y, int z): x(a), y(b), z(c) {}`这种方式初始化，这就是**成员列表初始化**。**`const`和引用类型的成员，只能用这种方式初始化**。

在C++11中，还提供了对**数组或者对象之类的成员**更方便的初始化方式。

参考：

```cpp
class demo {
    int a[2];
    
    // 表示用x,y初始化a[0],a[1]
    demo(int x, int y): a{x, y} {
        
    }
}

// 创建实例的时候也能用这种形式
demo d = {1, 2};
```

#### 拷贝构造函数

拷贝构造函数也是构造函数的一种，如果我们**将两个实例进行赋值，就会去调用这个构造函数**。和构造函数一样，不写默认会有一个实现。另外要注意，**默认实现是浅拷贝，也就意味着引用类型会共享内存地址**。此外如果我们**手动实现了拷贝构造函数，那编译器就不会执行任何操作**了。

如果一个**实例被作为函数参数使用，则也会触发拷贝函数**。这意味着传递对象给函数，会额外开辟一个新的对象空间。但如果我们**使用引用，就可以避免这个过程**。

如果一个**实例被作为函数返回值使用，则根据不同解释器会有不同结果**，有的解释器会把返回值也完整执行构造、析构、拷贝等，而有的解释器则会省略这些，在实际开发中应当避免这种用法。

这里再想想**为什么拷贝构造的参数是引用**。因为我们拷贝构造本质上是一个传参的过程，我们知道传参会触发拷贝构造，而引用不会，如果我们不写成引用，就会**无限触发拷贝构造**，结果就是死递归。

```cpp
#include <iostream>
#include <cstring>
#include "man.h"

using namespace std;

namespace funcspace {
	int (*pointer)(int, int);
}

int add(int a, int b) {
	return a + b;
}

class demo {
	private:
	 	char *str;

	public:
		
		demo(const char *s) {
			int len = strlen(s);
			str = new char[len + 1];
			strcpy(str, s);
			str[len] = '\0';
			cout << "construct" << endl;
		}
		
		demo() {
			cout << "construct" << endl;
			str = new char[100];
		}
//		
		void copy_str(char * &&d) {
			int len = strlen(d);
			str = new char[len + 1];
			strcpy(str, d);
			
			str[len] = '\0';
		}
		
		// 不会触发拷贝构造，不知道为什么w，因为GetDemo确实返回的是右值
//		demo(const demo &&it) {
////			cout << "copy" << it.str << endl;
//			cout << *it.get_str() << endl;
//		}

		void test(const demo &&it) {
//			cout << "test" << it.get_str() << endl;
			cout << &it << endl;
//			cout << it.get_str() << endl;
			strcpy(str, it.get_str());
			
		}

		char * get_str() const {
			return str;
		}
		
		~demo() {
			delete []str;
			cout << "destoryed" << endl;
		}
};

// 根据编译器不同对象返回值也会有不同处理，DevC++里就是直接优化成引用了
// 因为这样所以就不会再触发一次d2.test的拷贝构造，那这样其实有没有左右值引用都一样了
// 因为编译器已经优化了...
demo GetDemo() {
	demo d1("hello");
	cout << &d1 << endl;
	return d1;
}

int main() {
//	const demo d1("hello");
	// 这样写触发的只是简单的赋值，因为GetDemo返回的是个右值，不会触发
	// 拷贝引用
//	demo d2 = GetDemo();
	
	// 这样写可以触发&it拷贝，因为d1是个左值，但还是没法
	// 触发&&it，可能因为匹配不上拷贝构造
//	demo d2 = d1;
//	cout << d2.get_str() << endl;
	
	// 使用右值引用
	demo d2;
	d2.test(GetDemo());
	cout << d2.get_str() << endl;
	
	return 0;
}
```

这里再提提拷贝构造的本质是什么：我们调用拷贝构造时可能是通过`man m2 = m1`这种形式来的，但实际上**编译器会按`man m2(m1)`这种形式执行**，并且它们的效果是一样的。它们的区别就在于是否使用了赋值操作符`=`，但实际上**`=`并不代表一定会执行拷贝构造**。比如`man m2; m2 = m1`，**这种做法就只是把`m2`赋值成了`m1`，是不会去执行拷贝构造的**。

造成这种区别的原因就是**操作符**，详细内容在操作符重载记录。

#### 不可变对象

在创建实例时，我们可以使用`const`对实例进行修饰，这样它就是一个不可变的对象了。这样做之后，我们就**必须保证方法或者成员不可变**。即使是一个返回常量的方法，也得用`cosnt func() cosnt {}`这种方式进行修饰，主要目的是告诉编译器真的不可变，否则就会报错（解释了为什么排序的操作符重载需要这样写）。这样写之后`this`就没法访问外部变量了，因此**不可变对象只能调用不可变方法**。

```cpp
// h
// 这里返回值不需要加const修饰，因为int本身就不可变
// 如果是指针之类的引用类型，就需要加上const了
int get_age() const;

// cpp
int man::get_age() const {
	return age;
}

// main
const man m3 = man("asdf");
cout << m3.get_age() << endl;
```

#### 传递对象参数

**直接传递对象参数**，相当于在调用函数的栈空间里**又开辟了一份内存地址**，对象越大，效率越低。所以一般是**传递引用或者指针**，前者不开辟新空间效率最高。

```cpp
// 想要类只读，那就加上const修饰
void test(man &m) {}

void test2(man *m) {
	// 指针是通过->调用内部成员
    m->get_age();
}

int main() {
	man m;
    test(m);
    test2(&m);
    return 0;
}
```

#### explicit关键字

并不是某些网站的筛选关键词w...在C++中，可能会**有些操作能有不止一种方式实现**，比如下面赋值会去调用构造函数（可能是操作符重载的原因），`explicit`关键字就是用来**告诉编译器只能用指定方法调用**的。

```cpp
void man::man(int i) {}

// 这种方式会去调用上面的构造函数，即使看起来完全不像调用构造函数
man m = 1;
// 原因是C++确实支持这种初始化方式，比如（但括号只能用来初始化，=则没有这种限制）
int a(10);

// 这样就只能通过调用构造函数的方式初始化了
explicit void man::man(int i) {}
man m = man(111);
```

#### 静态类成员

我们知道，在C语言中，**使用`static`修饰的变量，会在程序创建时生成、程序销毁时回收**，C++也是如此。但C++中还有类的概念，不过实际上**类中的静态成员也是遵循这个法则的，它只是调用时要使用class::static的形式**，所以可以理解成给静态变量加了个作用域，静态成员本身和类是没什么其它关系的。另外**类中的静态变量是单例的**，无论创建多少个实例，静态变量永远只有一个。

```cpp
void test() {
    static int i = 0;
    cout << i << endl;
}

for (int i = 0; i < 10; i++) test(); // i 1-10

class man {
    public:
    	static int t;
    	int hhh = 0;
    	man(int tt) {
            // 这种做法是不允许的，因为静态成员t和man这个类没什么关系，程序启动时就存在了
            // t = tt;
        }
    
    	static void set_t(int i) {
            // 没问题，静态方法可以操作静态成员
            t = i;
            // 不行，因为静态方法在类实例化之前就存在了
            // hhh = i;
        }
}

// 这样做是没问题的，man类是否实例化都无所谓，它的作用只是给静态变量加个作用域
man::t = 1;
man::set_t(10);
```

#### 练习：单例模式字符串类

`main.cpp`

```cpp
#include <iostream>
#include "mystring.h"
using namespace std;

int main() {
	// 对应直接传入字符串，调用有参构造 
	mystring *str1 = mystring::makestring("hello world");
	cout << str1->get_str() << endl;
	
	// 对应不传入字符串，使用方法构造
	mystring *str2 = mystring::makestring();
	str2->set_str("hello C++") ;
	cout << str2->get_str() << endl;
	
	// 最后因为是单例模式，所以每次使用时实际是一个mystring对象（str1和str2），这就会导致同时设置再
	// 输出前者会被覆盖
	
	// 然后是清空self，任何一个实例调用都行，实际上不太明白这样做的目的...
	str2->release();
	
	mystring *str3 = mystring::makestring("karam police");
	cout << str3->get_str() << endl; 
	
	return 0;
}
```

`mystring.h`

```cpp
#ifndef MYSTRING_H
#define MYSTRING_H

class mystring {
	private:
        // 注意这里str不是只读的，如果是只读的话其实就只能在构造函数初始化了
		char *str;
		static mystring *self;

		// 单例模式的核心思想：通过禁用构造函数+使用静态变量存放全局实例
	public:
		void set_str(const char *str);
		const char *get_str();

		static mystring *makestring(const char *str = NULL);
		void release();
		
		mystring(const mystring &it);

	protected:
		mystring();
		mystring(const char *);
		~mystring();
};

#endif
```

`mystring.cpp`

```cpp
#include "mystring.h"
#include <cstring>

// 注意初始化的方式，这里static不是类型，是修饰符，所以不能写成 static type var这种形式
mystring *mystring::self = NULL;

// 构造函数，如果makestring有默认参数就用它创建新字符串，否则就用set_str
mystring::mystring(): str(NULL) {

}

// 只有第一次创建self会走到这里，所以直接分配空间就行了 
mystring::mystring(const char *str) {
	const int len = strlen(str);
	this->str = new char[len + 1];
	strcpy(this->str, str);
	this->str[len] = '\0';
}

mystring::~mystring() {
	delete []str;
}

// 创建字符串，单例的核心所在，通过一个静态变量self判断是否存在实例
mystring *mystring::makestring(const char *str = NULL) {
	// self如果为null，就创建一个，后续创建不为null就直接复用 
	if (self == NULL) self = new mystring(str);
	return self;
}

// 如果第一次调用不指定字符串，那就手动使用方法设置 
void mystring::set_str(const char *str) {
	if (self) {
		const int len = strlen(str);
		const int nowLen = strlen(this->str);
		
		// 如果空间不够就重新分配，否则复用
		if (nowLen < len) {
			delete []this->str;
			this->str = new char[len + 1];
			strcpy(this->str, str);
			this->str[len] = '\0';
		} else {
			strcpy(this->str, str);
		}
	}
}

const char *mystring::get_str() {
	return str;
}

void mystring::release() {
	if (self != NULL) {
		delete self;
		self = NULL;
	}
}
```

#### 友元

友元`friend`是C++中的一个特性，它允许我们**通过声明友元变量或者函数，让外部访问类中所有变量（包括私有变量）**。从字面意思上来理解就是声明一个类的朋友，这个朋友不受访问权修饰符的限制。注意**友元是单向一对一的，不存在传递关系**。

```cpp
class demo {
    private:
    	int a = 0;
    
    public:
    	// 友元函数
    	friend void test();
    	// 友元类
    	friend class demo2;
}

class demo2 {
    public:
    	demo2() {
            demo d();
            cout << d.a << endl;
        }
}

void test() {
    demo d = demo();
    // 可以访问
    cout << d.a << endl; 
}
```

#### 操作符重载

前面的拷贝构造函数中我们提出了一个`man m; m = m2`拷贝构造函数没有触发的问题。这是因为这个过程本来就不是调用拷贝构造函数，它实际上是进行了**等号赋值**。如果我们不处理它，会导致下面的问题:

要想解决这个问题，就需要操作符重载了。C++允许我们对除了`?:`、`::`、`.*`、`sizeof`、`.`以外的所有操作符重载。通过重载操作符，我们能**自定义不同操作符下实例执行的操作**。但要注意，**操作符重载只能改变执行行为**，**无法改变优先级、结合性、左右操作数等语言规定，也无法创建新操作符**。

**操作符重载也是多态的一种**，被称为**静态多态**；而后面的**父子多态就是动态多态**。

操作符重载的语法为`type operator op(const class &name)`，和其它成员函数一样，操作符也允许重载。

```cpp
class demo {
    private:
    	char *str;
    public:
    	~demo() {
            cout << "destoryed" << endl;
            delete []str;
        }
    	demo(const char *s) {
            int len = strlen(s);
            str = new char[len + 1];
            strcpy(str, s);
            str[len] = '\0';
        }
    	demo(const demo &it) {
            // 复制，代码同上
        }
    	
    	// 操作符重载，注意这里返回的是demo类型，如果我们的操作符不需要返回任何东西
   		// 可以直接定义为void
    	// 那为什么要返回demo对象呢?因为可能会有a = b = "hhh"这种情况，这在C++语法
    	// 中是完全没问题的，但如果返回void，就会导致a = b出错；返回this则又会执行
    	// 下面的复制操作，就能实现这种效果了。同理，其它重载也是这样写的。
    	demo operator =(const demo &it) {
            // 复制
            return this;
        }
    	
    	// 重载，直接给实例赋值字符串（代码简化)
    	demo operator =(const char *s) {
			strcpy(str, s);
            return this;
        }
    	
    	// 重载，给实例赋值数字
    	demo operator =(const int n) {
            sprintf(str, "%d", n);
            return this;
        }
    
    	// 左边是类的情况下，+只需要一元重载即可
    	demo operator +(const int n) {
            return this;
        }
    
    	// 设置友元函数，重载+操作符
    	friend demo operator +(char *s, demo &it);
    	
    	// class++的int参数是必须有的，即使没有什么意义
    	// ++class就需要实现二元操作符重载了
    	// 这也是二元重载，而且是demo++的意思
    	// 为了区分++demo所以要有个int i占位
    	// 为什么是二元重载呢？因为它是类内部重载的
    	demo operator ++(int i) {
            
        }
    	
    	// 一元重载，表示++demo
    	demo operator ++() {
            
        }
    
    	// demo++，相当于二元操作，所以要定义成友元函数
    	friend demo operator ++(const demo &it, int i);
}

// 二元重载，demo++形式
demo operator ++(const demo &it, int i) {
    
}

// 友元函数一元重载，表示++demo（注意区分demo++的类内部二元重载）
demo operator ++(const demo &it) {
    
}

int main() {
    demo d1  demo('hhh'), d2, d3;
    // 因为这里只是简单的赋值，所以不会触发拷贝构造，这也就意味着d2和d1是完全相同的
    // 如果d2触发了析构函数，那d1内的字符串也会被清除，即使它还存在引用
    d2 = d1;
    // 调用=号时，本质上是执行的这一串代码
    // d2 = d1.operator =(100);
    d3 = d2 = "asdf";
    
    d3 = d3 + 100;
    return 0;
}
```

在上面的例子中，我们使用的**一元操作符重载**，所谓一元实际上指的就是**参数个数**。但大部分操作符，**比如`+`，是需要两个操作数的**，也就需要**二元操作符重载**。而根据**类实例在左边还是右边，又有不同的情况**，具体见下：

1. 如果是`class + class`，或者`class + otherType`，这种情况只需要**一元重载**。因为它**相当于调用`demo.operator +(100)`这种形式**。
2. 如果是`otherType + class`，就需要**二元重载**了，因为`111.operator + (demo)`这种操作是不存在的。而且要注意，因为是**`111`去调用操作符**，所以**操作符重载得在全局定义（但并不是所有用到该操作符的情况都会被重载，而是根据参数类型来判断），而不是类内部**（相当于重新定义了一个`+`的调用场景）。这种方式一般是需要**通过友元+外部操作符重载**实现的，因为需要访问类私有成员。

另外要特别注意，**操作符重载的前提一定是至少有一个自定义类型参数**。为什么呢？因为如果都是基本类型我们可以把`+`改成`*`，把`\`改成`-`，这样编译器就没法正常工作了。

```cpp
class demo {
    private:
    	char *str;
    
    public:
    	// 二元重载，实现111.operator +(class)这种操作
    	friend demo operator +(char *s, demo &it);
}

// 不可以，因为参数全是基本类型
bool operator ==(int a, int b) {
    return a == b;
}

// 外部定义操作符重载函数，像+这种操作符是需要两个操作对象的，所以也称为二元操作符
demo operator +(char *s, demo &it) {
    demo result = demo(s);
    // 这里要访问私有变量，所以得设置友元
    strcat(result.str, it.str);
    return demo;
}
```

有些特殊操作符，比如`new`和`delete`，在重载时是要特别注意的。`new`规定必须接受一个`size_t`类型的参数，返回一个空类型指针；而`delete`规定必须接收一个空类型指针，并且返回值为空（以及二者和`operator`间必须有一个空格，其它操作符是可以省略空格的）。一般是不需要重载这两个操作符的，因为C++自带的就能满足绝大部分场景了。

另外要注意，**`new`即使被重载了，也没法取消原本就有的`new`行为**，也就是我们可以在重载中加入自己的代码，但没法替换原有的`new`逻辑。这具体体现就在**`new`无论是否重载，都会去调用构造和析构函数**。

```cpp
void * operator new(size_t size) {
    // size_t的大小就是sizeof(class) * new class[x] + 4字节
    return (this_type *)malloc(size_t);
}

// new []和delete []也是要单独重载的
void operator delete(void * cls) {
    // 注意强转，这里要把void *转成类指针类型，不然free是不止到释放内存空间大小的
    // 因为void *只是表示一个地址
    free (this_type *)free(cls);
}

// 不会调用构造函数和析构函数
demo d = (demo *)malloc(sizeof(demo));
free(d);

// 使用我们重载后的new，还是会调用构造和析构函数
demo d2 = new demo;
```

#### 左值右值和下标操作符

下标操作符的重载也是比较有意思的，它涉及到了**左值和右值**的概念。那什么是左值，什么是右值呢？简单来说，就是下面两个定义：

1. *左值 (lvalue, locator value)* 表示了一个**占据内存中某个可识别的位置（也就是一个地址）的对象**。

2. *右值 (rvalue)* 则使用排除法来定义。一个表达式不是 *左值* 就是 *右值* 。 那么，右值是一个 *不* 表示内存中某个可识别位置的对象的表达式。

左右值在C++11是一个比较重要的概念，但**区分它并不是字面上根据`=`号左右就行**。参考文章：[理解 C/C++ 中的左值和右值 | nettee 的 blog](https://nettee.github.io/posts/2018/Understanding-lvalues-and-rvalues-in-C-and-C/)。

这里简单做下概括：

1. 左值分为**可修改左值和不可修改左值**，像`const var = 1`，这里的`var`**虽然是一个占据了空间的值，但却不能修改**，所以是不可修改左值。
2. **左值可以转变为右值，但右值不能转变为左值**。`int i = 1, j = 2; int k = i + j;`，这里`i, j, k`都是左值，但**`i + j`表达式**产生的是一个**临时的不可修改值（常量）**，所以就变为了右值。
3. 可**通过引用来使左值变为右值的情况再变回左值**（前提是**该值本身就是左值**，而且这里不是右值变成了左值，因为原值就是左值）。这句话看起来比较绕，假设有这样的函数：`int global = 2; int & func() { return global; }`，它返回的`global`是可以被继续修改的。而如果我们**不返回引用，那`global`就会从左值变成右值**，进而无法修改。

关于C++11的左值右值，这里就先不记录了。

那么了解了这个概念，我们就能明白为什么`arr[i] = 1`这种操作是合法的了，因为它返回的是左值引用。下标操作符的实现原理就是这样。

```cpp
char & operator [](int idx) {
    return str[idx];
}
```

#### 移动构造函数

这是C++11新增的特性（教程里不知道会不会讲到）。在[#左右值和引用](#左右值和引用)遇到了传递对象不触发拷贝构造的问题，当时以为是编译器的优化。实际上原因是我们的类**实现了默认的移动构造函数**。移动构造函数的主要作用就是**使用右值引用，减少拷贝之类的操作创建新内存**。

```cpp
class demo {
	private:
    	int x;
    public:
    	// 可以发现它和拷贝构造的区别就在于一者是做左值引用，另一个是右值引用
    	demo (const demo &&it): x(10) {
            cout << "moving" << endl;
        }
}

demo d1;
// 会触发拷贝构造，因为它不是一个右值
test(d1);

// 会触发移动构造，因为函数返回的是一个右值
test(GetDemo());

// 将d1变成右值，也会触发移动构造
move(d1);
```

#### 匿名类

匿名类就是**没有类名的类**。这种类**无法实例化**，也**不需要实例化就能调用内部成员**，实际上是结构体的一种。

```cpp
class {
    public:
		void say() {
            cout << "hello world" << endl;
        }
} notitle;

// 不需要实例化就能调用内部成员
notitle.say();
```

#### mutable声明副作用

我们知道如果**把类实例用`const`修饰**，那它调用的**成员函数也得写成`type name const {}`这种形式**。这是为什么呢？实际上这里这个`const`是**告诉编译器这个成员函数不会修改成员变量**，相当于**把函数体里的内容限定为了只读**（可以理解成减少副作用）。

那如果我们需要**修改某个成员变量呢**？这时就需要用到**`mutable`关键字**了。它的作用就是告诉编译器可以对这个成员进行修改。

```cpp
class demo {
    private:
    	char *name;
    	int age;
    	mutable string address;
    public:
    	void say() const {
            cout << this->name << ' ' << this->age << endl;
 			// 报错，因为函数体内部只能为只读操作
            this->age = 10;
            // 用mutable修饰的成员可修改
            this->address = "hubei wuhan";
		}
}
```

#### 类嵌套实例构造析构顺序

这部分比较类似`Vue`中的声明周期的概念。假设我们在一个类中**嵌套了另一个类的实例**，那它们的**构造函数和析构函数的执行顺序**是怎么样的呢？**一般是最先构造嵌套的类，最后析构嵌套的类；最先析构包含的类，最后构造包含的类**。

其实简单来理解，为什么嵌套类实例反而是最先被构造的呢？因为**包含类中可能会有需要访问嵌套类的代码**，那如果**先实例化了包含类**，就可能出现**包含类访问嵌套类时嵌套类还没初始化**；同理，释放时也得**先释放包含类**，因为**先释放嵌套类**可能**导致需要用到嵌套类的地方访问出错**。

```cpp
class son {
    public:
        son() {
            cout << "son constructor" << endl;
        }
        ~son() {
            cout << "son destoryed" << endl;
        }
}

class father {
    public:
    	son s;
    	
    	father() {
            cout << "father constructor" << endl;
        }
        ~father() {
            cout << "father destoryed" << endl;
        }
}

// son constructor
// father constructor
// father destoryed
// son destoryed
```

#### 禁用默认构造

根据前面的知识我们知道，如果**不声明构造函数，编译器会帮我们自动生成一个**。在某些情况下，我们不想因为默认构造产生意外的结果，比如**禁用拷贝构造从而不允许其它人获取实例值**，此时就可以禁用构造函数。

一般而言，编译器会帮我们**自动生成下面几种构造**：

1. 构造函数
2. 析构函数
3. 拷贝构造
4. 重载`=`运算符

在声明时使用`class() = delete;`的语法就行了。

```cpp
class demo {
	public:
	   	// 显式声明默认构造函数
   		demo() = default;
    	// 禁用默认拷贝构造函数
    	demo(const demo &) = delete;
}
```

#### 类中成员的内存分析

感觉就是个概念w，所以就简单复制粘贴了..

```cpp
//类中的普通成员变量
//类名 变量名  //栈上
//类名 *指针名 =new  类名   //堆上
//类的静态成员  静态区
//成员函数，静态函数都在代码区，类的函数都是共享
//myclass myclass1(10, 9);
//int a(5);
```
#### 继承

继承也是面向对象的经典内容了，在C++里**支持单继承和多继承**，后者使用会相对较少，因为可能产生带环有向图。

##### 单继承

不管是单继承还是多继承，都可以通过**权限修饰符控制派生类访问基类的成员变量权限**，但**无论那种修饰符**，**子类实例都不能直接访问父类`private`成员，除非使用友元**（注意这里说的是实例，类内部还是能自由访问除了`private`以外的所有成员的）。

权限修饰符在继承上和类成员是一致的，`public`权限最高，`protected`其次，`private`最低。

**使用`public`修饰符**，相当于**没对基类权限做修改**（可访问基类中`public`变量）；**使用`protected`**，相当于**把基类中`public`变量变成`protected`的**；使**用`private`**则是**把`protected`和`public`都变成`private`的**。

这些权限操作符除了**控制实例访问权限**，还能**控制继承代数**：

1. `public`，因为不会改变基类成员权限，所以相当于可以**无限继承**（每一代都能访问到基类成员）。
2. `protected`，公有成员变成保护成员，**外部不可直接访问**，但还是可以**无限继承**。
3. `private`，公有和保护成员变成私有成员，**外部不可直接访问**，而且基类成员变成私有后**只能传递一代**。

在**父类和子类间有同名成员的时候**，**类中可以使用`this->father::var`**，**在类外可使用`obj.father::var`的形式访问**。但要注意，这里**即使同名也不会出现重载的情况**，也就是**父类和子类的函数作用域是独立的**。

```cpp
#include <iostream>
using namespace std;

class demo {
	private:
		char *name;

	public:
		int age;

    	static int i;
		static void test() {
			cout << "test" << endl;
		}
    	
    	// 构造函数
        demo(int a): age(a) {

        }

	protected:
		char *address;
};

// 注意要先初始化才能访问
int demo::i = 0;

class son1: public demo {
	public:
    	// 调用父类构造函数
		son1(): demo(1) {
			cout << this->age << this->address<< endl;
            // 访问父类对象
            this->demo::age;
            
            // 子类可以直接访问父类的静态成员
            cout << this->demo::i << endl;
			test();
		}
};

class son2: protected demo {
	public:
		son2(): demo(1) {
			cout << this->age << this->address << endl;
		}

		void t() {
			cout << age << address << endl;
		}
};

// 类内部访问没有限制
class son3: private demo {
	public:
		son3(): demo(1) {
			cout << this->age << this->address<< endl;
		}
};

int main() {
	son1 s1 = son1();
	son2 s2 = son2();
	son3 s3 = son3();
    
    // 如果子类和父类间有重名变量，调用时只能取到子类变量
    // 可以通过这种方式访问父类变量
    cout << s1.demo::age << endl;
	
    // s1只能访问基类的public变量age
    // s2,s3公有分别变成保护和私有变量，所以实例无法访问
	cout << s1.age  << endl;
    
    // 实例也可以直接访问父类静态成员
    son1 *sp = new son1();
	cout << sp->demo::i << endl;
	sp->test();
	
//	s.name;
	return 0;
}
```

##### 多继承和虚基类

多继承和单继承从功能上来说是类似的，都是给子类增加父类的功能。多继承在生命周期上类似类嵌套，**创建时父类优先，销毁时子类优先**。

关于多继承还有个虚基类的概念。我们在实现多继承时，可能会出现**派生三代甚至三代以上的情况**，如果第**三代派生类引用了多个第二代派生类**，并且第**二代派生类有相同基类**，那就可以**用虚基类来优化了**。

看下面的代码，如果我们不声明`Anc`为基类，则**两个子类`A/B`继承时会创建两次`Anc`**，并且因为`C`继承自`A/B`，**还可能出现`Anc`变量语意不明**的情况。所以简单总结，**虚基类可以让被多次引用的基类只创建一次，而且还能消除二义性**。

```cpp
class Anc {
    public:
    	int a;
    	Anc() {
            cout << "anc created" << endl;
        }
    
    	Anc(int x) {
            a = x;
        }
    	~Anc() {
            cout << "anc destoryed" << endl;
        }
}

class A: virtual public Anc  {
    A() {
        cout << "A created" << endl;
    }
    ~A() {
        cout << "B destoryed" << endl;
    }
}

class B: virtual public Anc {
    B() {
        cout << "B created" << endl;
    }
    ~B() {
        cout << "B destoryed" << endl;
    }
}

class C: public A, public B {
    C() {
        cout << "C created" << endl;
    }
    ~C() {
        cout << "C destoryed" << endl;
    }
}
```

#### 类与指针

C++中可以通过指针完成父子类间的互相访问，然而根据情况的不同可能会有各种结果。

##### 普通继承

这种情况是最简单直观的，因为父子指针没有互相调用，就是一个继承的关系。所以结果和继承也是一样的，**子类实例方法和成员会覆盖父类**（意思是调用时同名成员各自调用各自的）。

```cpp
#include <iostream>
using namespace std;

class father {
	public:

		char str[100];

		father(): str("father") {
			cout << "father constructor" << endl;
		}

		void say() {
			cout << "father says" << endl;
		}
    
   		~father() {
            cout << "father destoryed" << endl;
        }
};

class son: public father {
	public:
		char str[100];
		son(): str("son") {
			cout << "son constructor" << endl;
		}

		void say() {
			cout << "son says" << endl;
		}
    
    	~son() {
            cout << "son destoryed" << endl;
        }
};

int main() {
	father *f = new father;
	son *s = new son;
	
	cout << f->str << endl;
	cout << s->str << endl;
	
	f->say();
	s->say();
	
	return 0;
}
```

##### 父类指向子类（多态）

这种情况**父类依然能正常调用自己的方法**，**不会出现被子类覆盖的情况**。这是为什么呢？我们可以从内存角度思考。把继承关系的内存当成一个盒子，子类从父类继承而来，因此**子类盒子中包含父类内存**。此时去`new son`，相当于**把子类的大盒子空间给父类，因为父类本身就在其中，所以产生交集后拿到的就是自身的内存空间**。

这实际上就是**多态**的体现（~~但似乎并不是，因为这里**调用父类方法拿到的还是父类成员**，要想实现**类似多态的效果**，得通过下面的**子类指向父类+虚函数完成**~~，这只是演示父类指针移动的原理），如果我们**要调用子类方法**，还得进行**父到子的类型转换**，更详细的见下面多态部分的内容。。

再内存释放方面，如果我们**把父对象删掉**，会发现**子对象并没有跟着析构**，也就造成了**内存泄漏**。

```cpp
father *f = new son;
cout << f->str << endl;
f->say();

// son没有被析构
delete f;
```

##### 子类指向父类

这种情况的行为是**无法预知**的，大概率会导致程序崩溃。还是以上面内存盒子的角度思考，子元素盒子中**除了父元素盒子的部分就是自己的内存（成员变量等）**，那此时我们强行将父元素赋值给子元素，就相当于**把子元素自己的空间给抹除了**。这时子元素成员变量之类的**内存地址都是未定义**的，所以去调用就会把程序搞崩。

下面这串代码可能会有不同运行结果。此外我们这里用的是`static_cast`进行类型转换，实际上**用`dynamic_cast`才是符合对象类型转换**的，但它需要用到**虚函数**，所以先跳过。

准确来说**调用成功否**是**根据子类调用的方法是否引用到了内部数据**来的。如果**没有引用**，比如下面`s->say`，就**没问题**，如果**有引用到**，就会导致**程序崩溃**。

如果我们**把子对象删掉**，会**产生内存越界**，能否正常执行程序也不确定。

```cpp
father *f = new father;
son *s = static_cast<son *>(f);

cout << f->str << endl;
cout << s->str << endl;

f->say();
s->say();
```

#### 多态和虚函数

多态是面向对象三大特性之一。在C++中实现多态需要**类指针、虚函数、类型转换等步骤**。~~一般大部分语言，比如`Java`，实现多态是`father obj = son`这种形式，也就是左父右子；但C++中实现多态似乎是`son *obj = static_cast<son *>(father)`这种形式，也就是**左子右父**。~~它的本质还是**函数指针**。

我们依然以之前提到的内存盒子来理解多态：在继承关系下，**每一级父类都是派生类内存盒子中的一小部分**。这也就是为什么我们直接把子类指针指向父类，会产生程序错误。但如果我们反着来，把**子类盒子（内存空间）设置给父类**，此时没有任何问题，只是**调用时依然调用父类方法**。原因也很简单，因为**父类盒子中只能装下父类的公有方法**。

那如果我们**不是直接把内存赋值给父类**，而是**把子类盒子的地址交给父类，再把父类指针类型转为子类**会怎么样呢？这时就**相当于用父类中的公有方法，去调用子类重写方法了**。当然这个**前提是要进行父到子的类型转换**，因为如果我们不转换，父类面前就有**父类方法+子类方法**两种调用情况，但因为C++是强类型，所以它只会去调用自己的方法。

实际上这个过程说的简单点就是**指针的移动**，**父类可以将自己的指针移动到任意自己的子类盒子上，然后通过强转的方式调用子类盒子里的方法**。

下面的代码就实现了一个最简单的多态。C++中**多态的本质**就是**函数指针和指针地址移动**。

```cpp
#include <iostream>
using namespace std;

class father {
	public:

		char str[100];

		father(): str("father") {
			cout << "father constructor" << endl;
		}

		void say() {
			cout << "father says" << endl;
		}
};

class son: public father {
	public:
		char str[100];
		son(): str("son") {
			cout << "son constructor" << endl;
		}

		void say() {
			cout << "son says" << endl;
		}
};

int main() {
	father *f = new father;
    son *s = static_cast<son *>(f);
    
    // 把子类内存地址给父类，此时父类就指向子类盒子
    // 再进行类型转换就可以调用子类方法了
    f = static_cast<son *>(s);
    // 调用子类方法
    f->say();

	return 0;
}
```

上面代码中我们要想使用父类调用子类方法，得手动进行类型转换。虚函数就是用来解决这个问题的。**父类中声明为虚函数的成员函数，在调用时会优先调用子类同名方法**。也就是通过虚函数把父类同名函数的优先级设置成低于子类同名函数。

虚函数本质上是一个函数指针，用它声明的函数会多出来4个字节（64位系统就是8个字节）。要**想声明一个成员函数为虚函数**，只需要在类型前面**加上`virtual`关键字**即可。

虚函数有下面的几个特点:

1. 一个虚函数，在派生类层面相同的重载函数都保持虚特性。也就是说**只要基类设置为虚函数，派生类重载也默认是虚函数**。
2. **虚函数必须是类的成员函数**。
3. 不能将友元说明为虚函数，但**虚函数可以是另一个类的友元**。
4. **析构函数可以是虚函数（可以用来避免内存泄漏）**，**构造函数不能是虚函数**。
5. 区别普通重载，**虚函数重载**要求函数的**参数列表**、**返回值**、**函数名完全相同**，否则会丢失虚性。

```cpp
#include <iostream>
using namespace std;

class father {
	public:

		char x;

		father(): x('X') {
		}
		
    	// 声明say为虚函数
		virtual void say() {
			cout << "father says " << x << endl;
		}
    
        virtual ~father() {
            cout << "father destoryed" << endl;
        }
};

class son: public father {
	public:
		char y;
		son(): y('Y') {
		}

		void say() {
			cout << "son says " << y << endl;
		}
    	
    	// 此时将father指针删除，因为father函数析构为虚函数，所以会优先调用
    	// son的析构方法，这样就能避免内存泄漏了（son析构后顺带把father析构）
 		~son() {
            cout << "father destoryed" << endl;
        }
};

class child: public son {
	public:
		char z;
		child(): z('Z') {
		}

		void say() {
			cout << "child says " << z << endl;
		}
};

int main() {
    // 声明为虚函数后，就不需要手动类型转换了，所以我们可以直接简写成Java这种
    // 形式
	father *f = new son;
	
    // 因为say在父类中是个虚函数，所以优先调用子类say
	f->say();


	return 0;
}
```

#### 纯虚函数和抽象类

纯虚函数最大的特点就是**没有方法体**，要求**子类对该方法进行实现**。**抽象类就是包含纯虚函数的类**。使用这种方式我们能指定一个规范，所有继承抽象类的子类都得实现自己的纯虚函数。

纯虚函数的语法：`virtual void say()=0`。

抽象类主要的限制是**不实例化就不能使用**，所以普通抽象类**没法作为函数参数和返回值使用**，但我们可以**使用指针代替**。

```cpp
#include <iostream>
using namespace std;

class demo {
	public:
    	// 声明虚函数，教程里还得写个空语法体，这里只需要写声明就行
		virtual void say()=0;
};

class child: public demo {
	
};

// 抽象类不能直接作为参数和返回值，因为没法实例化，得使用指针代替
demo * test(demo *d) {
    return d;
}

int main() {
    // 不实现say就没法实例化
	child * ch = new child;
	return 0;
}
```

#### 模板类

模板类和函数模板是一样的，只不过把**泛型声明提到了类上**。`STL`中，大部分容器都是使用类模板来完成可复用性的，比如`vector/map`之类的。

如果我们是**类中声明，类外定义**的写法，那**定义时也需要带上`template`**，而且要和类定义的完全一致（默认值）。

**模板类进行继承时，类型也要明确声明**，也就是继承类要么也是个模板，要么就直接指明特定类型。

模板类的其它操作，比如**友元**等，也是要**带上模板类型**的，所以总结就是**保证类型一致就行**。

模板类中的**`static`变量**，会变成**每一个类型一份**，而不是整体一份。

```cpp
#include <iostream>
using namespace std;

// 设置默认参数类型
template<class T=int>
class box {
	public:
		T data;
	    // num会变成每一个类型一份
    	static int num;
		box() {
			
		}
		box(T data) {
			this->data = data;
		}
		void say() {
			cout << data << endl;
		}
    
    	T hello(T data);
};

box::num = 0;

// 把类型也跟着继承下去
template<class X>
class box2: public box<X> {
    
}

// 也能设置固定类型
template<class T, int>
class demo {
    
}

// 如果是外部定义，也需要带上类模板和默认值
template<class T=int>
T hello(T data) {
    cout << data << endl;
}

int main() {
    // 只要用到类就得声明<Type>
	box<int> b1 = box<int>(1145);
	box<char *> b2 = box<char *>("hello world");
	
	b1.say();
	b2.say();
    
    // 访问时需要带上类型，不同类型间静态变量不相同
    cout << box<int >::num << endl;
    cout << box<char >::num << endl;
	
	return 0;
}
```

#### final和override

`final`关键词可以用来声明**该函数拒绝重载**；`override`关键字则用来声明**该函数就是用来重载的**。要使用这两个关键词，**必须将拒绝重载/明确重载的方法声明为虚函数**。

`final`语法:`virtual void say() final {}`；`override`语法：`void say() override`，注意，它是**用在子类上明确声明该函数是重载父类的**。

**`override`关键字的重载**和之前的`virtual`重载是一样的，**返回值、参数列表、函数名必须完全相同**。

我们还可以**把一个类声明为`final`的**，这样就表示**类拒绝继承**。

```cpp
#include <iostream>
using namespace std;

class father {
	public:
		// 拒绝重载和明确重载都需要将方法声明为虚函数
    	virtual void say() final {
			cout << "father says" << endl;
		}
		
		virtual void hello()  {
			cout << "hello" << endl;	
		}
};

class unanc final {
    
}

class son: public father /* , public unace，报错，final类不可继承 */ {
	public:
		// 不允许重载	
//		void say() {
//			
//		}
		// 明确重载
		// 注意参数列表返回值必须完全相同，否则不算重载
		void hello() override {
			cout << "hello" << endl;
		}
};

int main() {

	return 0;
}
```

#### 类嵌套匿名类

有时候我们想在一个类中**用匿名类表示某个数据结构**，这时就涉及到了类的嵌套。其实类的嵌套和普通变量声明也没多大区别，下面列举一些情况供参考:

```cpp
template<class K>
class father {
	public:
    	// 普通匿名类，直接声明就行，可以当成结构体用
		class {
			int age;
			char *name;
		} temp;
		
    	// 模板类和前面提到的一样，要从父类传递类型
		template<class T>
		class tobj {
			
		}; 
    	// 实例化模板类型
		tobj<K> t1;
		tobj<int> t2;
};

// 调用就当普通变量来即可
f.temp.age;
f.t1;
```

### makefile

#### 基础操作

这块不知道怎么分类，也算比较重要的内容，所以先单独拿出来。

在`windows`平台下，我们可以借助各种开发软件直接对编写好的项目进行编译。但在`Linux`下，是没有这么多的工具的，因此只能通过手动调用`g++`，或者编写`makefile`来实现。一般C/C++程序变成可执行文件是有**编译和链接**两个步骤的，`g++`也遵守这个规则。

C++程序一般**使用`g++`进行编译**，它的两个**常用指令，`-c`和`-o`**，分别是进行**编译和指定输出文件名**。比如`g++ -o main.o -c main.cpp`，就会生成一个`main.o`文件。如果是**单文件**的情况下，那我们**可以直接执行**它；但如果是**多文件**，那么这一步就**只是生成这个文件的C++程序语法结构**。什么意思呢?就是说**它引用的其它文件都是不会参与到这个过程的**，这时直接执行就会报错了。那如何把其它文件加进来呢？也很简单，把其它文件编译，然后通过`g++ -o app main.o test.o`，这种形式就行了，**这一步就是链接**。

`makefile`本身是类似一个脚本语言的工具，通过它我们能编程式的进行编译链接，也就能剩下很多重复工作。下面假设我们有一个`main.cpp`，它引用了`t.h`，编写一个`makefile`来进行编译：

```makefile
// makefile里是可以使用变量的，约定成俗用大写表示变量
CC=g++

// 执行make默认调用这个命令
// 这里后面跟的main.o，t.o表示该命令依赖这两个文件，如果没有就会去执行对应的命令
start: main.o t.o
	// 引用变量，注意这里要用tab缩进，这是语法要求
	$(CC) -o myapp main.o t.o
	
// 生成main和t的目标文件
main.o:
	$(CC) -o main.o -c main.cpp

t.o:
	$(CC) -o t.o -c t.cpp
	
// 清除.o文件，也是约定成俗的，注意它不会自动执行，所以得手动指定要运行这个命令
// 目标文件的生成是根据文件修改日期来的，也就是并不是每次执行都会生成一次，只有没有或者源文件发生改变时才会进行
// 如果项目体量很大，保留目标文件能减少编译时间
clean:
	rm -rf main.o t.o
```

#### 变量简化

上面的代码中有个问题，就是我们每次加入新文件都需要重新写一个配置，这也是老生常谈的问题了，解决方法就是**通过维护变量来省去重复代码**。

```makefile
CC=G++

SRCS=main.cpp\
	 t.cpp

// 这段代码用来生成目标文件，它的意思是把SRCS变量的.cpp替换成.o，这样我们就只需要维护
// SRCS这个变量了
OBJS=$(SRCS:.cpp=.o)

// 最终生成的可执行文件名
EXEC=myapp

start: $(OBJS)
	$(CC) -o $(EXEC) $(OBJS)
	
// 表示对.cpp和.o后缀的文件进行下面的处理
// 在start: $(OBJS)的时候就会调用这个
.cpp.o:
	// 这里的$@和$<都是占位符，我们在编译时实际执行的是 g++ -o obj.o -c obj.cpp
	// 这两个占位符就是把这里的obj.o和obj.cpp取出来填充，这样就不需要每个文件都手写一次了
	$(CC) -o $@ -c $<
	
// 清空.o文件
clean:
	rm -rf $(OBJS)
```

#### C/C++混合使用

想要在C++中调用C语言代码，或者想在C语言中调用C++代码，都是没法直接完成的。但我们可以通过**链接库**来完成两者间的互相调用。具体见下面的代码：

`max.c`，链接库的实现代码。

```c
int main(int a, int b) {
    return a > b ? a : b;
}
```

`makelib`，用来编译动态链接库。

```makefile
// C语言使用gcc编译
CC=gcc

SRCS=max.c

OBJS=$(SRCS.c=.o)

// 在unix平台下，必须使用lib*.so的格式声明链接库
EXEC=libmaxtool.so

start: OBJS
	// fPIC这个参数是创建位置无关的文件，函数位置由调用者确定
	// 什么意思呢?假设我们库里函数起始地址为0x00，然后每各0x20创建一个新函数，那
	// 如果我们调用者的函数也是这样分配空间的，就会照成冲突，不指定位置就能让调用者分配地址了
	$(CC) -o $(EXEC) $(OBJS) -fPIC
	
.c.o:
	$(CC) -o $@ -c $<
```

`mymax.h`，声明`max`函数，函数由链接库实现。

```cpp
#ifndef MYMAX
#define MYMAX

// 这个地方要注意，因为我们函数是要给C/C++调用的，所以要判断当前调用环境
// 如果是C++编译器环境，会有个__cplusplus常量，C编译器则没有，判断它是否定义就能知道语言环境
// 如果是C++编译器环境，因为这是个C语言编写的函数，所以要用extern "C"来保证不会重命名

#ifdef __cplusplus
extern "C" {
#endif
    
int max(int a, int b);
    
#ifdef __cplusplus
}
#endif
    
#endif
```

`makefile`，C++代码的编译程序，需要指定链接库。

```makefile
CC=g++

start: main.o
	// 主要注意这里的-L和-l
	// -L后面接的是链接库的文件路径，.就表示当前路径
	// -l表示链接库的名称，因为unix下默认lib开头，so结尾，所以只需要写中间的名称就行
	$(CC) -o myapp main.o -L. -lmymax
	
main.o:
	$(CC) -o main.o -c main.cpp

	
clean:
	rm -rf main.o t.o
```

### C++语法

从第四天开始看了眼视频暂时不知道怎么分类w，因为这部分似乎就是讲的C++语法...另外发现原来培训班包了差不多四个多月的内容，C++语法只是其中一小部分...

前面类的基础知识肯定也是这一部分的内容，但方便区分就单独放出来。

#### C++和C的区别

1. **C++的类型判断更加严格**，在C里，可以把不同类型的指针直接进行赋值；而在C++中必须通过强转。
2. **C存在变量名全局污染的问题**，C没有命名空间，也没有重载，所以同名函数必然会造成冲突。
3. C++中的`endl`，存在**换行和结束输入的作用**。也就是`cout << "hh"; cout << "ww";`其实相当于`printf("%s%s")`（解释了为什么OI里喜欢把`endl`定义为`\n`）。
4. C没有提供**变量重名的情况下如何访问全局变量的方法**，而C++可以使用`::`访问，这是因为不指定就默认当成全局。
5. C++中要**引用文件作用域的全局变量**，必须明确**使用`extern type var`**，而C默认不需要。
6. **C++引入文件不用`.h`，是为了区分命名空间**。

#### 命名空间

在前面杂项和常识的部分就有关于命名空间的知识了，这里主要是扩展。

1. 命名空间**可以通过重命的形式进行扩展**，但**同名命名空间**内的**变量不可重名**。
2. 命名空间可以进行**嵌套**。
3. **命名空间内一般不写函数，只留一个函数指针**，这样做能够**在功能改动时只修改函数，而不是命名空间**。
4. **命名空间内所有成员都为公有**，而类默认为私有，结构体默认为公有。
5. `using namespace`只能在命名空间后使用，作用域为**下文所有代码（函数内就以块作用域为标准）**。如果**不同命名空间中存在同名变量**，则需要**使用`::`指明使用那个命名空间**。
6. **命名空间常用于迭代开发**，使用命名空间可以一遍编写代码一遍扩展，而不影响其它人。

```cpp
#include <iostream>
using namespace std;

namespace a {
    int i(10);
    
    namespace b {
        int j(20);
    }
}

// 扩展命名空间
namespace a {
    int k (33);
    // 不行，命名空间可重名进行扩展，但内部变量不行
    // int i (10);
}

namespace funcspace {
    // 函数指针
    int (*pointer)(int, int);
}

// 命名空间别名
namespace tt = a;

int add(int a, int b) {
    return a + b;
}

// 在函数中使用
void test() {
    using namespace tt;
    cout << a << endl;
}

using namespace a;
using namespace tt;
int main() {
    // 嵌套使用
    cout << a::i << ' ' << a::b::j << endl;
    
    // 使用函数指针去指明函数功能
    funcspace::pointer = &add;
	cout << funcspace::pointer(1, 20) << endl;
    
    // tt和a里都有a这个变量，所以要明确时那个命名空间在用
    cout << tt::a << endl;
    return 0;
}
```

#### 函数重载的原理与默认参数

在C++中，可以通过**不同参数列表同名函数**的方式进行**函数重载**，那它的原理是什么呢？关键就在于函数的参数列表。我们知道C++函数重载后实际上**函数名是有变化的**，那**如何确定我们调用的是那个函数呢**？答案是**根据参数列表**。**编译器会使用函数参数列表来生成不同地址的函数，传入不同的参数就会调用对应地址的函数**。这也就解释了为什么**函数的重载和返回值无关**。我们可以使用函数指针来验证：

```cpp
#include <iostream>
#include <stdio.h>
using namespace std;

void func(int a) {
    cout << a << endl;
}

void func(double b) {
    cout << b << endl;
}

void func(char c) {
    cout << c << endl;
}

int main() {
    // 拿到不同参数列表的func的函数指针
    void (*f1)(int) = func;
    void (*f2)(double) = func;
    void (*f3)(char) = func;
    
    // 接下来取地址，可以发现不同参数下地址不同
    printf("%p/n", f1); // 0x00
    printf("%p/n", f2); // 0x20
    printf("%p/n", f3); // 0x40
    
    return 0;
}
```

如果想明确使用C语言函数，可以用`extern "C"`来声明（前面提到过），这样就会**用C编译器编译**。

如果函数的**默认参数和函数重载调用形式和调用参数类型是相同**的，那就会报调用不明确的错误：

```cpp
int func(int a, int b = 1, int c = 2) {
    
}

int func(int a) {
    
}

// 报错，因为这种形式既可以匹配上默认参数，也能匹配int重载
func(100);

int func(dobule a) {
    
}

// 没问题，因为可以匹配上double重载
func(100.0);
```

#### 自动类型auto

`auto`可以用来**自动判断变量类型**，它用来遍历数组是非常方便的，不需要指定范围就能遍历整个数组。但是要注意，**`auto`遍历时要保证作用的是一个常量**，它**只能用来遍历一维数组**，因为二维数组取出来的是一个指针，无法确定范围。

```cpp
int arr[2][5] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};

int nums[3] = {1, 2, 3};

// 直接遍历整个数组
for (auto n: nums) {
    cout << n << endl;
}

for (auto data: arr) {
	for (int i = 0; i < 5; i++) {
        // data为一维数组的首地址，访问二维就使用下标的形式
        cout << *(data + i) << endl;
    }
}
```

在**不确定变量类型或者类型写起来很繁琐的情况**下，也可以使用`auto`。C++中还提供了**`typeid(type).name()`这种方式动态获取类型，`decltype(type)`定义类型**。

```cpp
double unknow_type = 0.11;

cout << typeid(unknow_type).name() << endl;

decltype(unknow_type) db(100);
```

#### 左右值和引用

关于引用要注意的一点是，引用一旦被**初始化**，**引用变量自身**的地址就会**在符号表上固定**，后续**不可变**，即**引用的地址不可变**，即使引用指向变量改变。

关于左值右值的概念，参考[#左值右值和下标操作符](#左值右值和下标操作符)。这里我们就要探讨引用和左值右值的关系了。首先来看引用和指针。我们知道引用就是给变量起别名，这点在指针上同样适用：

```cpp
#include <iostream>

using namespace std;

int main() {
	int *p = NULL;
	int num = 10;
	
	p = &num;
	
    // 这里&pn就是拿到p的地址引用，加上指针就变成了*p，是一样的效果
	int *(&pn) = p;
	
    // 相当于修改p
	*pn = 114;
	
	cout << *pn << endl;
	return 0;
} 
```

上面这个例子就是左值引用。**左值引用可以减少开辟新的栈空间内存，以及起到变量别名的作用**。此外还有**常引用**，也就是**使用`const`修饰引用**，此时就**可以引用右值了，但只能读取，不能修改**：

```cpp
// 引用右值
const int &ttt = 10;

// 它的原理就是通过一个中间变量存放值，再引用这个变量，这个过程会开辟新的内存空间
const int temp = 10; 
const int &var = temp;
```

右值引用的目的也是提升性能，减少内存消耗。具体来说是**充分利用右值(特别是临时对象)的构造来减少对象构造和析构操作以达到提高效率的目的**。它也是采用**临时变量**的形式实现的，但区别在于**右值引用可修改**。语法`类型 && 引用名 = 右值表达式;`。

下面这个例子展示了右值引用是如何进行构造优化的。这里`demo2`是一个右值引用。（实际上是移动构造优化）

```cpp
#include <iostream>
#include <cstring>
#include "man.h"

using namespace std;

namespace funcspace {
	int (*pointer)(int, int);
}

int add(int a, int b) {
	return a + b;
}

class demo {
	private:
	 	char *str;

	public:
		
		demo(const char *s) {
			int len = strlen(s);
			str = new char[len + 1];
			strcpy(str, s);
			str[len] = '\0';
			cout << "construct" << endl;
		}
		
		demo() {
			cout << "construct" << endl;
			str = new char[100];
		}
//		
		void copy_str(char * &&d) {
			int len = strlen(d);
			str = new char[len + 1];
			strcpy(str, d);
			
			str[len] = '\0';
		}
		
		demo(const demo &it) {
			cout << "copied" << endl;
		}
		
		// 不会触发拷贝构造，不知道为什么w，因为GetDemo确实返回的是右值
//		demo(const demo &&it) {
////			cout << "copy" << it.str << endl;
//			cout << *it.get_str() << endl;
//		}

		void test(const demo it) {
//			cout << "test" << it.get_str() << endl;
			cout << &it << endl;
//			cout << it.get_str() << endl;
			strcpy(str, it.get_str());
//			str = it.get_str();
//			cout << &str << endl;
		}

		char * get_str() const {
			return str;
		}
		
		~demo() {
			delete []str;
			cout << "destoryed" << endl;
		}
};


demo GetDemo() {
	demo d1("hello");
	cout << &d1 << endl;
	return d1;
}

void test(demo& m) {
	cout << m.get_str() << endl;
}

int main() {
//	const demo d1("hello");
	// 这样写触发的只是简单的赋值，因为GetDemo返回的是个右值，不会触发
	// 拷贝引用
//	demo d2 = GetDemo();
	
	// 这样写可以触发&it拷贝，因为d1是个左值，但还是没法
	// 触发&&it，可能因为匹配不上拷贝构造
//	demo d2 = d1;
//	cout << d2.get_str() << endl;
	
	// 使用右值引用，传入
	demo d2;
	d2.test(GetDemo());
	cout << d2.get_str() << endl;
	
	test(d2);
    
    // 右值引用，引用地址（地址是右值）
    int a = 10;
    int * && pt = &a;
	
	return 0;
}
```

引用在和指针配合使用时，可能造成一些难以理解的问题（这里并没遇到堆上的`a`被清除，`r`输出值不同的情况）：

```cpp
#include <iostream>

using namespace std;

int * & test() {
	int *a = new int;
	
	*a = 10;
	
	int * &pa = a;
	
//	*pa = 10;
	
	return pa;
}

int main() {
	int * &r = test();
	
	cout << *r << endl;
	cout << *r << endl;
	
	return 0;
}
```

#### cosnt修饰符

##### 各种用法

C/C++中都有`const`修饰符，然而**C中的`const`其实是没法完全保护变量不可修改的**（因为它是弱类型语言）。

```c
#include <stdio.h>

int main() {
    const int a = 10;
    
    // 虽然类型不相同，但还是允许赋值
    int *p = &a;

    // 成功修改
    *p = 20;
    
    return 0;
}
```

C++则非常严格，只要是**使用`const`修饰的变量，就没法修改**（似乎可以通过注入修改，不过这里还没讲到）。

```cpp
#include <iostream>
using namespace std;

int main() {
    const int a = 10;
    
    // 报错，因为const int和int是不同类型
    int *p = &a;
    
    // 通过强转赋值，不报错但不会成功（*p会改变，但a不会）
    int *p = (int *)&a;
    *p = 20;
    cout << *p << ' ' << a;
    
    // 通过C++的形式去掉const，不报错，但还是无法修改（注意这里的括号）
	int *p = const_cast<int *>(&a);
    *p = 20;
    cout << *p << ' ' << a;
    
    return 0;
}
```

另外C++的`const`还能有多种使用方式（它们的意思可以根据`const`之后修饰变量的位置来区分）：

**指向常量的变量指针**：`const int * var`/`int const * var`，这种两种写法的作用是相同的，意思是**指针指向的是常量**，**不可修改指向的值，但可修改指向的地址**。

```cpp
int a = 10;
int b = 20;
const int * p = &a;

// 不行，指向的是常量
*p = 20;

// 可改变指向地址
p = &b;
```

**指向变量的常量指针**：`int * const p`，这种写法表示**不可修改指向地址，但可修改指向值**。

```cpp
int a = 10;
const int b = 20;

int * const p = &a;
// 可以
*p = 20;

// 不行，不可修改指向地址
p = &b;

// 不行，因为b本身就是常量，没法通过*p2修改
int * const p2 = &b;
```

**指向常量的常量指针**：`const int * const p`这种写法就是**完全只读**的。与其它情况不同，**只读的变量不会作用C++的强类型检测**，而可读或者可写的变量都会有强类型检测，这样做的目的是方便按权限编程。

```cpp
int a = 10;
const int b = 20;

// 没问题，因为p是只读的，所以不会有强类型检测
const int * const p = &a;

const int * const p2 = &b;
```

**常引用**：就和前面解释过的一样，**常引用可以直接引用右值或者保证引用的值无法通过引用修改，但原值仍可修改**。

```cpp
int var = 10;

const int &a = var;
// 不行，因为常引用不能改变引用对象的值
a = 10;
// 可以，因为原引用并不是常量
var = 20;
```

##### 对比#define以及原理

我们知道C中也是可以定义常量的，使用`#define N 100`就行了，但**这实际上并不是常量，也没有类型检测**。因为我们可以**通过重复定义的方式覆盖掉上个定义**。而C++的`const`则解决了这些问题。它的原理是**把常量，比如`100`直接映射成值（`0x64h`），而不是存放在内存中**。这样就保证了**常量一定不可变**，即使我们使用指针去修改了对应地址的值，也不会改变，因为**常量本身就不存放在地址中**。

此外**`const`还会进行自动类型检测**，`const int i = 100.11`，存放的是`100`。而且我们可以把非`const`参数传递给`const`参数，这时值是从内存取的。

```cpp
const int i = 100;

int *p = &i;

// 原地址内的值改变了，但i的值本身就不存放在内存中，所以不会受影响
*p = 200;

void test(const int i) {
    cout << i << endl;
}

int a = 10;
// a不需要定义为const，这里会从内存中取值
test(a);
```

##### 常量实例

我们可以使用`const`来修饰类实例，这样做了之后就**只能调用`int name() const {}`这种返回值不可变的方法**。原因是类成员调用时会加上一个隐式的形参`* const this`，而我们将成员用`const`修饰后就变成了`cosnt * cosnt this`，于是就没法通过`this`改变外部成员了。

```cpp
#include<iostream>
#include<cstring>
#include<cstdlib>
#define  MOD(x,y)  x % y
using namespace std;

class Ttt {
	public:
		static int t;
		
		void test() {
			
		}
		
		int t2() const {
			return 1;
		}
};

int main(void) {

	const Ttt t = Ttt();
	
	t.t2();
    // 没法调用，因为test不是常量返回值
//	t.test();
	return 0;
}
```



#### new和delete

在C++中，**`new`可以用来给指针在堆上内存**，`delete`则用来**释放内存**。和C的`free`类似，**`delete`也只能释放一次**。

这里要注意，因为我们是使用`new`把内存分配在堆上了，所以**`auto`增强`for`循环是用不了的**，它**只能在栈上使用**。

```cpp
int *t = new int[10];
// 报错
for (auto dd: t) {

}

delete t;
// 程序崩溃
delete t;
```

用`new`分配二维数组内存：

```cpp
// 先把80个元素放一行
int *p = new int[80];
// 再每十个取出来设置成列，这里要强转，把变量名去掉就是类型
// (*px)[10]是个二维数组，每行10列，所以得到的结果就是8行，10列的二维数组
int (*px)[10] = (int(*)[10]) p;
// int (*px)[10] = new int[80]; 不行，因为 new 只能分配线性空间

int d = 0;

for (int i = 0; i < 8; i++) {
    for (int j = 0; j < 10; j++) {
        px[i][j] = d++;
    }
}
```

##### 重载劫持（代理模式）

通过前面的知识我们知道`new`和`delete`重载后要自己设计一个是非常困难的，但我们可以**利用全局的`new`和`delete`完成功能，在这之间添加自己的代码**。比如利用静态变量，统计创建和销毁了多少个实例；或者**将删除后的指针置空**，**防止重复删除导致程序崩溃**。

这种设计技巧甚至可以模拟`Java`的**内存回收机制**（这里跳过）。

```cpp
class demo {
    public:
    	static int count;
    	static void * operator new (size_t size) {
            demo *dpt =::new demo;
            
            cout << "劫持new" << endl;
            
            count++;
            return dpt;
        }
    
    	static void operator delete(void * d) {
            ::delete d;
            // 防止重复delete导致程序崩溃
            d = NULL;
            cout << "劫持delete" << endl;
            count--;
        }
}

int demo::count = 0;
```

##### 构造析构的意义

在上面的代码中，如果我们**使用`new`来创建实例**，会发现**构造和析构函数被执行了两次**。这时因为**构造函数和析构函数只有在有内存空间的情况下才有意义**，所以第一次分配调用一次，真正分配调用一次。

```cpp
demo *d = new demo();
```

##### 全局重载

我们可以通过全局重载的方式来**监听所有对象内存的分配行为**。

```cpp
// size_t无符号整数，因为不能分配负空间内存
void * operator new(size_t size) {
    return malloc(size);
}

void * operator new[](size_t size) {
    return new(size);
}
```

##### 限定区域分配内存

我们直接使用`new`，**内存的地址是由系统决定**的。假如我们想**限定某一块内存分配空间**，就需要用到这种做法了。

这两种用法是有下面的区别的:

1. 如果是**直接使用**不指定内存区，那**指针变量存在栈区**，**存储地址指向堆区**，且需要**手动释放内存**。
2. 如果是**指定内存区**，那**指针变量存在栈区**，**存储地址指向静态区，自动释放内存**。这样做的好处就是**避免内存泄漏**，**自动释放内存**，但缺点就是**牺牲了内存访问的独立性**。

```cpp
const int N(5);
const BUFFER_LEN(500);

char buffer[BUFFER_LEN];

// 自动分配内存
int *p = new int[N];

// 指定内存分配区为buff
int *p2 = new (buffer)int[N];
```

#### 引用高级

先来看两道面试题，要求说明各部分的意义（这种模式在信号编程会用到）：

```cpp
// 把每部分简化再分析
// 最外层
int * T(int, Y);
// T调用的指针函数
int * Y (int);
// 所以可以发现它实际上是一个返回T类型函数指针，参数为int的函数
int (* z(int x, int (*y)(int)))(int);
// 下面这个同理，只是加上了引用
int (* & z(int x, int (* &y)(int)))(int);
```

引用本质上是对变量起别名，那么**别名的类型直接参考原类型**就行，这里以二维数组为例：

```cpp
int a[2][5] = {1, 2, 3, 4, 5, 6, 7, 8, ,9, 10};

// 可以发现就是把变量名a换成了引用&ra，其它部分都是不需要改的
int (&ra)[2][5](a);
```

**引用+函数指针+函数返回值**，会出现令人非常疑惑的代码：

```cpp
#include <iostream>
using namespace std;

int add(int i, int j) {
	return i + j;
}

// 把函数指针作为参数使用
int myadd(int a, int b, int (* &pa)(int, int)) {
	return pa(a, b);
}

// 使用函数改变函数指针的引用
void changeadd(int (* &pa)(int, int)) {
	pa = sub;
}

// 返回一个函数引用，这种情况先简化，再替换类型
// 返回sub类型的指针
int (*& psub(int (*&rp)(int, int)))(int, int) {
	return rp;
}

// 上面这个奇奇怪怪的东西就能返回一个*& (int, int)类型的函数指针引用
// 接下来把它分流程简化下
// 要返回函数指针
// int (*& rp) {}
// 返回函数指针的参数为int, int（注意这里是返回函数指针参数，不是调用函数指针参数）
// int (*& rp)(int, int) {}
// 函数的参数为sub的函数指针，也就是subpoi = int (*&psub)(int, int)
// 组合int (*& rp(subpoi))(int, int) {}
// 最后这个rp就是函数名

// 传入changeadd，再返回changeadd
// 这里的void是返回的调用函数指针类型，不是函数返回值类型
// 返回函数指针类型 void *& rc
// 返回函数的参数int (* &pa)(int, int)，另一个指针函数
// 组合void *& rc(int (* &pa)(int, int))
// 调用函数参数，就是上面的rc
// 调用函数...（感觉这样分析不太公式化，下面给个公式化的操作方法）
void (*& changep(void (* &pa)(int (* &pa)(int, int))))(int (* &pa)(int, int)) {
//	pa = sub;
//	return pa;
	return pa;
}

// 返回函数指针类型 (*& 调用函数名(传入参数))(返回函数指针参数) {
// 
// }

int main() {
	int (*p)(int, int) = add;
	int (* &pa)(int, int) = p;
	cout << myadd(10, 20, pa) << endl;
    
    // 变成了sub
    changeadd(pa);
	cout << pa(10, 20) << endl;
    
    // 大概这样使用
    changep(changeadd)(sub);
}
```

无论是左值引用还是右值引用，都**不能引用一个数组**。因为这样表示数组中每一项都是引用，这在C++中是不允许。

```cpp
int &a = [1, 2, 3];
```

最后，**引用也能使用`const`进行修饰，并且规则和指针是相同的**。参考：[#const修饰符](#const修饰符)。

#### 枚举enum

C和C++中都有枚举类型，但C语言是**弱类型**的，这也就意味着**枚举可以不为同一类型，也可进行重定义**。

```c
// 从0开始，依次递增，但无法限制类型
enum color { red, blue, yellow ,purple = 'P' };
```

C++则更加安全，在声明时我们就**可指定类型，并且无法更改**。

```cpp
// 限定全为char，默认值依然从0开始
enum color: char { red = 'A', blue, yellow, purple };


// 取值
color mycolor = color::purple;
color color2 = purple;

// 报错，只能赋值为限定类型
mycolor = 'A';
```

#### 函数模板

函数模板可以使用**泛型类型指定函数参数类型**，这样我们就不需要编写多个功能相同参数类型的函数来完成功能了。

它的语法是`template<typename T>`，还有之前提到的`template<class T>`，它们意思是一样的。注意，如果我们使用了函数模板，那**参数列表中必须至少有一个模板类型的参数**，否则无法匹配上对应函数。

一般情况下**`typename`和`class`是可以互换的**，但如果我们是`typename T::Subtype * str`这种情况，就**要带上`typename`**，因为不带**会解析成乘表达式**。

##### 配合可变参数

这里还要提个新知识：**可变参数**。可变参数就类似`JS`里的剩余参数，能接受**任意数量的位置参数**。但C++中并没有提供那么高层次的封装，所以还得**借助`cstdarg`库来取出可变参数**。

```cpp
#include <cstdarg>

template<typename T>
// ...就是可变参数
T sum(T count, ...) {
    // 存放参数列表的指针
    va_list arg_ptr;
    // 限定从count开始，剩余多少个参数
    va_start(arg_ptr, count);
    T result(0);
    for (int i = 0; i < count; i++) {
        result += va_arg(arg_ptr, T);
    }
    va_end(arg_ptr);
    return result;
}
```

##### auto自动推导

如果我们的模板函数**不止有一个类型**，并且**返回值由这些类型共同决定**，就需要使用`auto`类型来进行推导了。这里要用到一个新语法，`template<typename T, typename N> auto func(T a, N b)->decltype {}`。

```cpp
template<typename T, typename N> auto func(T a, N b)->decltype {
    return a + b;
}

// 使用也用auto声明就行了
auto res = func(1, 1.0);
cout << typeid(res).name() << endl;
```

##### 特殊函数模板

我们前面的写法`template<typename T>`叫做通用函数模板，因为任何类型只要传进去就能使用。但有时候我们想仅仅**针对特定的类型编写函数模板**，就需要用到特殊函数模板了。它的语法是`template<> type func(type){}`，可以发现**和通用函数模板的区别就是没有泛型，类型在参数上明确指明**。

这里还有个小知识，如果类成员**都是公有变量**，那就可以用`{}`的方式进行初始化。

```cpp
class info {
    public:
    	char *name;
    	int age;
}

// 通用模板
template<typename T> void swap(T &t1, T &t2) {
    // ...
}

// 特殊模板，二者虽然用法相同，但如果指明类型会优先调用特殊模板
template<> void swap(info &i1, info &i2) {
    info temp;
    temp = i1;
    i1 = i2;
    i2 = temp;
}

// 都是公有变量，可以这样初始化
info user = {"hwz", 21};
```

##### 重载调用规则

和特殊函数模板的情况类似，有时我们**既有通用函数模板，又有自己写的重载函数**，那此时会去调用谁呢？实际上编译器会对这种情况进行优化，默认是**优先调用重载函数**的。但有时我们就是想要调用通用函数模板，这时就需要**使用`swap<int>`这种方式**了，它表示**将函数模板实例化为`int`类型**。

```cpp
template<typename T>
T add(T a, T b) {
    cout << "T a + b" << endl;
    return a + b;
}

int add(int a, int b) {
    cout << "int a + b" << endl;
    return a + b;
}

// 调用int add
add(1, 2);
// 调用通用函数模板
add(2.1, 2.4);
// 实例化函数模板并指定为int类型，调用函数模板
add<int>(1, 2);
```

##### 通用可变参数模板

在[#配合可变参数](#配合可变参数)这一届节，我们使用可变参数实现了任意数量数相加的函数。但可以发现这种做法比较繁琐，不仅要引入头文件，还得手动指定`count`。

通用可变参数模板可以解决这种问题。它是**将可变参数也作为模板类型**的一种模板。如果我们要使用这种模板，还得**声明一个空函数接口**（只做接口使用，实际调用还是模板函数）。

```cpp
// 空函数接口，必须声明它，否则调用时就会按函数模板匹配
void showall() {}

// 这里...Args是表示一个类型，相当于把...取名为Args了
template<typename T, typename ...Args>
// 而这里的Args ...args就是可变参数了
void showall(T value, Args ...args) {
    cout << value << endl;
	// 递归处理可变参数
    showall(args);
}
```

##### 配合引用包装器

我们知道函数模板可以传入任意类型的参数，这其中包括引用参数。但如果**函数模板的参数不是引用类型**，那我们**即使传入引用也没法修改原值**（因为这时会**变成拷贝参数，地址不同**）。如果函数模板的参数本身就是引用，那我们传入引用就可以正常修改了。

但为了完成这样的功能单独再去重载或者实现一次无疑是非常麻烦的。引用包装器，就是用来解决这种问题的。**引用包装器的语法是`std::ref(变量)`，它可以把一个变量包装成引用类型，函数模板就能正确接收应用了**。

**引用包装器和引用是完全不同的**，如果我们**在普通函数参数上使用引用包装器，那是完全没效果**的，它只有在函数模板这种需要类型推导的情况下才会生效。

```cpp
#include <iostream>
using namespace std;

template<typename T>
void add(T arg) {
	arg++;
}

int main() {
	int cnt = 0;
	int &rcnt = cnt;
	
    // 没有效果
	// add(&cnt);
	// add(rcnt);
		
    // 修改成功
    // 然而不知道为什么编译失败了，这玩意似乎不存在w
    add(ref(cnt));
	cout << cnt << endl;	
	return 0;
}
```

#### inline内联函数

C语言中我们可以使用`#define`来定义一些功能简单的函数，以达到优化的效果。但这样做**无法保证类型安全**，也没法保证函数不被**重定义覆盖**。

C++中则提供了`inline`来解决这个问题。符合`inline`条件的函数在调用时会**直接把函数体执行，而不是入栈新函数**。当然，并不是所有声明为`inline`的函数就会如此，它只是建议编译器这样编译，具体行为得看函数是否满足下面的几个条件：

1. 不能有递归
2. 不能包含静态数据
3. 不能包含循环
4. 不能包含`switch`或者`goto`语句
5. 不能包含数组

如果我们声明的内联函数无法满足上面的条件，就会被当成普通函数处理。

```cpp
// 可以使用函数模板+内联函数实现通用功能
template<typename T>
inline T getSum(T a, T b) {
    return a + b;
}
```

另外在原则上如果我们在类中使用内联函数，只需要将**`inline`定义在头文件里即可**。

```cpp
class demo {
    public:
    	inline void say_hello();
}

// 定义可以不带inline
void demo::say_hello() {
    
}
```

#### C和C++的细节差异

C相对C++而言有些细节上的缺陷，下面就一一列举：

1. **C没法将内存中存在地址的右值自动转为左值**，C++则会**根据右值在内存中是否有实际地址自动转换**。这主要体现在一些**返回右值的表达式**里，`(a = 3)=4; (a ? 1 : 2) = 3;(++a)++;`，这种表达式在C中是非法的，而C++会将右值转为左值。
2. C的**全局变量**存在**定义和声明的区别**，因此**可以声明多次**；C++则不存在这种区别，**只能声明一次**（包括静态全局变量）。全局定义`int a; int a; int a;`在C中是合法的，在C++中就是非法的。
3. **C的函数可以没有返回值**，C++是**强类型系统**，**函数必须有返回类型**。
4. **C的`register`变量无法取地址**；C++编译器会**根据`register`是否有取地址行为决定放不放到寄存器里**。
5. C没有**占位参数**；C++允许占位参数，方便扩展。`void func(int a, double, char) { cout << a; }`，这串代码中`double/char`是没有变量名的，在C中只有声明时可以这样做，而C++允许我们声明这种占位参数，即使编译器不会把这些参数加到函数里。

#### 宽字符本地化

像中文、韩文之类的语言都是使用`utf-8`存储的，~~在C++中不能直接输出它们~~，需要使用**宽字符**。此外还需要注意，只是使用宽字符存放字符串还是不能直接输出，得**设置本地化标志才行**。

```cpp
#include <iostream>
// 本地化标准头文件
#include <locale>

using namespace std;

int main() {
    // 把宽字符的本地化标准设置为简体中文，这样才能正常显示
	setlocale(LC_ALL, "chs");
    // 注意类型转换，要用L标识
    wchar_t *p1 = L"JS你这个凑标志";
    // wcout用来输出宽字符
    wcout << p1 << endl;
    return 0;
}
```

#### 函数包装器

函数包装器是C++11的新语法，它就像字面意思一样，可以将**函数放到包装器函数里，在包装器函数中处理额外逻辑**。其实从功能上来说就是方便我们把函数作为参数传入到另一个函数里。它的本质还是函数指针。

因为要把函数作为参数传入，所以用函数模板能省去我们声明函数指针的繁琐过程，还能提升通用性。另外这里的**`[外部参数列表](函数参数列表){函数体}`其实是`lambda`表达式**。

这里还有个C++11的新语法：`using std::function`，表示只单独引用`function`。

函数包装器可以有下面几种作用：

1. 实现**函数拦截**（根据条件是否满足决定是否执行）、**调用计数**。
2. 实现**函数嵌套**。
3. 利用**模板函数**实现**通用泛型**。
4. **管理外部函数**（直接赋值，**代替函数指针**）。

```cpp
#include <iostream>
// 要使用函数包装器得使用这个头文件
#include <functional>
using namespace std;

// 声明包装器，第二个类型就是函数
template<typename T, typename F>
T wrapper(T i, F fun) {
    cout << "enhanced" << endl;
	return fun(i);
}

int mut(int i) {
    return i * 2;
}

int main() {
    // C++11的新语法，可以只引用单独的命名空间
    using std::cin;
    using std::function;
    
	// 包装器语法:
	// function<返回值(参数列表) = [](参数列表) { //函数体 };
	function<int(int)> func = [](int i) {
		return i * 2;
	// 注意这实际上是个表达式，所以末尾也得加分号	
	};
    
    // 这里可以直接把函数赋值，说明它实际上就是个函数指针
    function<int(int)> func2 = mut;
	
    // 单独调用
	cout << func(10) << endl;
    
    // 使用包装器加强
    cout << wrapper(10, func) << endl;;
	
	return 0;
}
```

#### CPP类型转换

##### 隐式显式类型转换

和C语言一样，C++也有隐式转换和显示转换。一般而**言隐式转换会发生在传参、构造初始化时**；而**显示转换就是赋值时通过`()`强制转换**。区分它们的最好方式就是**看有没有类型标识符**。

```cpp
// 隐式转换
int num(10.8);

// 显式转换
int t = (float)11.4;

class demo {
    public:
    	explicit demo(int n) {
            cout << n << endl;
        }
}

// 显式转换，这里可以通过强转的方式满足explicit
demo d = (demo)10;
// 报错，不满足explicit
demo t = 10;
```

##### 基本数据类型转换

我们前面提到的`const_cast`可以把`const`类型转为非`const`类型，但像指针之类的变量还是没法修改地址。而`static_cast`，则是用来**强制类型转换**的。它的作用和C的`(int)`这种是相同的。

`reinterpret_cast`可以**转换内存中不同类型的指针数据**，一般可用`static_cast`代替，可以将任意类型转为指针，不是万不得已不需要用。

`dynamic_cast`则可进行**父类子类（对象间的）的数据类型转换**，同样功能`static_cast`也能完成，但如果是**类型不一致的情况，它会返回错误地址的指针**，而**`dynamic_cast`返回的是`void *`**，相对而言更加安全。

```cpp
const int *p = 20;

int *pt = const_cast<int *>(p);

// 不行，类型不同
const int *i = malloc(int);

// 可以，相当于把void *转为了 int *
const int *j = static_cast<int *>(malloc(int));

int *k = 123;
// 用来转换指针指向地址的数据类型
char *t = reinterpret_cast<char *>(&k);
```

这里还得提提`dynamic_cast`，它实际上是用来**实现多态类型转换**的。要使用`dynamic_cast`，被转换类中**必须存在一个虚函数**，否则去调用重载函数会拿到空指针。实际上关于这个教程里还没怎么详细提到w，目前先记这么多了...关于这个知识还有个**`rtti`实时类型检测**，也是一样，提到就当记了w。

##### 自定义类类型转换

C++中类**类型的转换**主要是**通过操作符重载完成**的。区别于`+-*/`之类的操作符，这里重载的**操作符为要转换的类型**，**不能有参数，不能作为友元函数**，必须要**返回对应类型的结果**。

```cpp
#include <iostream>
using namespace std;

class demo {
	private:
		int n;
	public:
		explicit demo(int n) {
			this->n = n;
		}
		
    	// 发生int类型转换时，把类的值当成n
		operator int() {
			return n;
		}
};

// 不支持友元
friend operator float() {
    
}


int main() {
	demo d = (demo)10;

	int t = d;
	cout << t << endl;
	return 0;
}
```

#### 高级数组

##### array数组

###### 基本使用

`array`是C++中提供的一种高级数组，它的**作用和普通数组是基本类似的，但可进行数组间整体操作，且适用于任何类型**，用起来更加方便。这里我们要区分`vector`，**`array`没有提供变长之类的方法**。

而且**`array`是一个放在栈上的静态数组**（`vector`是放在堆上的动态数组），这意味着我们**分配空间过多时会产生栈溢出**。

**`array`在初始化类实例数组**时比C风格数组好用很多，所以更多**用于复杂类型数组**。

```cpp
#include <iostream>
// 要引入这个头文件
#include <array>
#include <string>

using namespace std;

int main() {
    // 初始化一个长度为4的int类型数组
    array<int, 4> arr1 = {1, 2, 3, 4};
    array<string, 3> arr2 = {"hello", "hello", "how low"};
	// 二维数组（2行4列）
    array<array<int, 4>, 2> arr3 = { arr1, arr1 };
    
    // array提供了swap方法，可以直接把两个数组内容互换
    arr1.swap(arr2);
    
    // 系统默认栈大小1M，分配8M内存，爆栈
    array<double, 1024 * 1023> db;
    return 0;
}
```

###### 迭代器遍历

和`vector`类似，`array`也提供了**迭代器**接口：

```cpp
#include <iostream>
#include <array>

using namespace std;

int main() {
	array<int, 5> arr = {1, 2, 3, 4, 5};
	
	for (array<int, 5>::iterator it = arr.begin(); it != arr.end(); ++it) {
		cout << *it << ' ' << endl;
	}
	
    // 反向迭代
    array<int, 5>::reverse_iterator cbegin, cend;
	cbegin = arr.rbegin();
	cend = arr.rend();
	
	while (cbegin != cend) {
		cout << *cbegin << endl;
		++cbegin;
	}
    
	return 0;
}
```

###### foreach和lambda遍历

C++中提供了`for_each`函数（包含在`algorithm`头文件里），它**可以遍历迭代器范围内的数据**，和JS类似，它也是通过一个回调函数处理，为了方便，我们可以使用**`lambda`函数**。

```cpp
#include <iostream>
#include <array>
// for_each头文件
#include <algorithm>

using namespace std;

int main() {
	array<int, 5> arr = {1, 2, 3, 4, 5};

    int res = 0;
	
    // 使用引用操作外部变量，res等价于返回值
	for_each(arr.begin(), arr.end(), [&res](int x){
		res += x;
	});
	
	cout << res << endl;
	
	return 0;
}
```

##### vector变长数组

这部分内容只是提到了，还没讲到，先留个位置...

似乎只是讲了各种方法的使用...

##### tuple元组

和`Python`中的类似，C++中的元组也是**不可变，可混用任意数据类型**的。

```cpp
tuple<int, char, char *> mytuple(1, 'A', "hello world");

// 使用get<下标>的方式取值
auto = std::get<0>(mytuple);
```

#### lambda表达式

语法什么的看上面的[#foreach和lambda遍历](#foreach和lambda遍历)或者[#函数包装器](#函数包装器)就可以了。这里单独再开是因为这块比较重要，而且教程里讲的不全面。

下面是一些补充:

```cpp
{
    // 这里[=]表示直接操作函数体中用到的数据，相当于把外部参数当成函数传进去了（自动捕获外部参数，只读，也就是不相当于引用）
	// 注意它的作用域范围是当前块语句
    int num = 0;
    auto fun = [=](){
        cout << num << endl;
    };
}

{
    int n = 0;
    auto fun3 = [=]() {
        cout << n << endl;
        // 只能引用当前块里的变量
        // cout << num << endl;
    }
}

{
    int t = 0;
    // 按照引用的方式传入局部变量，和=的区别就是可读可写
    auto fun = [&]() {
        t++;
        cout << t << endl;
    }
}

{
    // 函数参数形式传入外部变量引用，可读可写
	int a = 10;
    auto fun2 = [&a](){
        num++;
        cout << num << endl;
    };
}

// 一个自执行匿名函数
[](){ cout << "hello world"; }();

// ->type设置返回值
auto nn = []()->int{ return 114; };
// 可以配合decltype使用
auto res = []()->decltype(nn){ return nn };
```

`lambda`函数的一些注意点

C++ 11中的Lambda表达式用于定义并创建匿名的函数对象，以简化编程工作。Lambda的语法形式如下：
`[函数对象参数](操作符重载函数参数) mutable或exception声明->返回值类型{ 函数体 }`。

可以看到，Lambda主要分为**五个部分**：
[函数对象参数]、(操作符重载函数参数)、mutable或exception声明、->返回值类型、{ 函数体 }。下面分别进行介绍。
一、[函数对象参数]，标识一个Lambda的开始，这部分必须存在，不能省略。函数对象参数是传递给编译器自动生成的函数对象类的构造函数的。
函数对象参数只能使用那些到定义Lambda为止时Lambda所在作用范围内可见的局部变量（包括Lambda所在类的this）。函数对象参数有以下形式：
1、空。没有使用任何函数对象参数。
2、 = 。函数体内可以使用Lambda所在作用范围内所有可见的局部变量（包括Lambda所在类的this），并且是值传递方式（相当于编译器自动为我们按值传递了所有局部变量）。
3、&。函数体内可以使用Lambda所在作用范围内所有可见的局部变量（包括Lambda所在类的this），并且是引用传递方式（相当于编译器自动为我们按引用传递了所有局部变量）。
4、this。函数体内可以使用Lambda所在类中的成员变量。
5、a。将a按值进行传递。按值进行传递时，函数体内不能修改传递进来的a的拷贝，因为默认情况下函数是const的。要修改传递进来的a的拷贝，可以添加mutable修饰符。
6、&a。将a按引用进行传递。
7、a, &b。将a按值进行传递，b按引用进行传递。
8、 = ，&a, &b。除a和b按引用进行传递外，其他参数都按值进行传递。
9、&, a, b。除a和b按值进行传递外，其他参数都按引用进行传递。
二、(操作符重载函数参数)，标识重载的()操作符的参数，没有参数时，这部分可以省略。参数可以通过按值（如：(a, b)）和按引用（如：(&a, &b)）两种方式进行传递。
三、mutable或exception声明，这部分可以省略。按值传递函数对象参数时，加上mutable修饰符后，可以修改按值传递进来的拷贝（注意是能修改拷贝，而不是值本身）。
exception声明用于指定函数抛出的异常，如抛出整数类型的异常，可以使用throw(int)。
四、->返回值类型，标识函数返回值的类型，当返回值为void，或者函数体中只有一处return的地方（此时编译器可以自动推断出返回值类型）时，这部分可以省略。
五、{ 函数体 }，标识函数的实现，这部分不能省略，但函数体可以为空。

#### 仿函数（引用类内部函数)

仿函数是指**取出类或者结构体中公有成员函数，单独调用的函数**。要完成这个操作我们需要**使用`bind`函数**，实际上这个操作本质就是**用函数指针，取出类地址中的特定函数**。

`bind`函数的语法：`bind(&类/结构体::特定函数, &类/结构体实例, _1, _2, ...占位)`。这里的`&`是取地址，`_1/_2`是参数占位符，想要正确调用必须严格匹配。

`bind`包含在`functional`头文件中，`_1`占位符则需要从`std::placeholders`命名空间里取。

```cpp
#include <iostream>
#include <functional>
using namespace std;
using namespace std::placeholders;

struct demo {
	public:
		void say() {
			cout << "hello world" << endl;
		}
		
		int add(int a) {
			return a + 10;
		}
};

int main() {
	demo d1;
	
    // 注意是从实例里取，因为要访问当前实例的内部变量
	auto say = bind(&demo::say, &d1);
	say();
	
    // _1占位
	auto add = bind(&demo::add, &d1, _1);
	cout << add(10) << endl;
    
    // 可以这样去去内部函数的地址，所以本质还是函数指针
    int (demo::*t)(int) = &demo::add;
	auto t2 = &demo::add;

	return 0;
}
```

#### 智能指针

普通指针在指向一片内存后，就会一直引用，除非我们使用`delete`销毁。而智能指针就是可以**自动判断内存是否可释放，如果可以，就自动释放**。使用它可以优化程序内存占用。

智能指针分为C++98和C++11两种，C++98的语法是`auto_ptr<type> name(ptr);`（不知道为什么C++11里没有，注意**它不能直接`new`内存，只能间接指向内存指针**，已被弃用）。

这里还有其它两种智能指针，参考：[C++智能指针之shared_ptr与右值引用(详细))](https://www.cnblogs.com/wanghongyang/p/15003611.html)，因为教程还没提到所以先放着。

微软的教程参考:[智能指针（现代 C++） | Microsoft Learn](https://learn.microsoft.com/zh-cn/cpp/cpp/smart-pointers-modern-cpp?view=msvc-170)。

##### unique_ptr

它是一种独占的智能指针，也就是**一个指针管理一块内存**。语法是`std::unique_ptr<type> name(new type);`，它**包含在`memory`这个头文件里**。

`unique_ptr`是用来代替C++98的`auto_ptr`的，与其相比占空间更少，可**引用右值**。在绝大多数情况下，它都是**智能指针的最好选择**。

特点：**可移动指向地址，但不能进行复制**。

```cpp
#include <iostream>
#include <memory>
using namespace std;


struct demo {
	public:
		void say() {
			cout << "hello world" << endl;
		}
		
		int add(int a) {
			return a + 10;
		}
};

int main() {
    // 可以直接new
	unique_ptr<int> pi(new int);

    int t = new int;
    // C++98智能指针只能间接引用
    auto_ptr<int > at(t);
	return 0;
}
```

使用`make_unique`来创建指针实例：

```cpp
unique_ptr<Song> SongFactory(const std::wstring& artist, const std::wstring& title)
{
    // Implicit move operation into the variable that stores the result.
    return make_unique<Song>(artist, title);
}

void MakeSongs()
{
    // 创建一个unique_ptr指针实例
    auto song = make_unique<Song>(L"Mr. Children", L"Namonaki Uta");

    // Use the unique_ptr.
    vector<wstring> titles = { song->title };

    // 移动指针指向
    unique_ptr<Song> song2 = std::move(song);

    // Obtain unique_ptr from function that returns by value.
    auto song3 = SongFactory(L"Michael Jackson", L"Beat It");
}
```

##### shared_ptr

这种智能指针是采用**引用计数**来进行内存回收的，因此占两个指针大小。用法什么的参考微软教程或者找文档了w...

##### weak_ptr

弱引用指针，也就是**不计数版的`shared_ptr`**，它的作用是避免**两个`shared_ptr`循环引用从而导致计数无法消除**。

#### 多线程

这块似乎教程就说了这么多，得单独看博客补课了w...

另外从效率上来说看博客和书肯定是更快的，以前学前端早就得到的结论...只不过很难说一本书，一整个C++知识点都能抱着书啃完，何况还要自己思考...

##### 基本使用

这里先简单看看怎么用。多线程在C++中是`thread`类，它包含在`std::this_thread`这个命名空间中。声明了一个多线程类，~~**并不会直接去调用这个多线程**，**得手动执行`join`才行**~~（并不是这样，构造函数会直接执行，但似乎会报错，所以还是得用方法调用）。

在这里主要用到了两个方法，**`join`，合并到线程队列中，会阻塞主线程**；**`detach`，分离出主线程，多个线程执行顺序不确定**。如果想**判断某个线程是否还可继续创建，可以使用`joinable`方法**，`join/detach`都是如此。

```cpp
#include <iostream>
#include<thread>
using namespace std;
using namespace std::this_thread;

void say_hello(int num) {
	cout << "hello world" << ' ' << num << endl;
}

int main() {
    // 构造线程时可以传入参数
	thread t(say_hello, 1), t2(say_hello, 2);
	
    // 顺序执行，后面的线程等待前面线程执行完毕再执行（准确来说顺序执行的原因是阻塞了主线程）
	t.join();
	t2.join();
    
    // 执行前最好判断当前线程是否可继续执行
    if (t.joinable()) t.join();
    
    // 乱序执行，创建两个脱离主函数的线程立即执行，完成顺序不确定
    t.detach();
    t2.detach();

	return 0;
}
```

##### 死锁和相关概念

参考：[C++多线程并发基础入门教程 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/194198073)。

这里再介绍下**死锁**的概念，因为我们需要保证资源在多个线程同时操作下的正确性，所以得加锁。但如果**产生了死锁**，就**会导致所有线程均无法访问资源**，从而卡死。

**产生死锁的四个必要条件（面试考点）：**

1. **互斥**（资源**同一时刻**只能被**一个进程使用**）
2. **请求并保持**（进程在请资源时，**不释放**自己已经**占有的资源**）
3. **不剥夺**（进程已经获得的资源，在进程**使用完前**，**不能强制剥夺**）
4. **循环等待**（进程间形成**环状的资源循环等待关系**）

要**解决死锁**，可以使用下面的方法:

1. **死锁预防：**破坏死锁产生的**四个条件**（完全杜绝死锁）
2. **死锁避免：**对分配资源做安全性检查，确保**不会产生循环等待**（**银行家算法**）
3. **死锁检测：**允许死锁的发生，但**提供检测方法**
4. **死锁解除：**已经产生了死锁，**强制剥夺资源**或者撤销进程

**临界区、信号量、互斥量（锁）的区别与联系**：

1. **临界区**：速度最快，但只能作用于**同一进程下不同线程**，**不能作用于不同进程**；临界区可确保某一代码段同一时刻只被一个线程执行；
2. **信号量**：多个线程同一时刻访问共享资源，进行**线程的计数**，确保同时访问资源的**线程数目不超过上限**，当访问数超过上限后，不发出信号量；P操作 申请资源；V操作 释放资源；
3. **互斥量**（锁）：比临界区满，但**支持不同进程间的同步与互斥**；

**同步与互斥**：

1. **同步指维护任务片段的先后顺序;**用`JS`的`promise`理解，就是后一个`promise B`依赖前一个`promise A`的返回值，直到`A`执行完毕前`B`都无法执行。
2. **互斥就是保证资源同一时刻只能被一个进程使用；**也就是资源只能独占使用。

##### 互斥锁

互斥锁即**同一资源同一时间，只允许一个线程访问**。它就像打饭一样，饭桶同一时间只能一个人打，其它人都得等前面人打完才能接着打。

在C++中提供了多种类型的互斥锁，下面分别介绍。

最基本的`mutex`锁：它的特征就是**上锁和解锁都得手动进行**，如果我们忘了其中一步，就可能造成线程间数据访问出错。

```cpp
#include<iostream>
#include<thread>
#include<mutex>
using namespace std;
mutex m;//实例化m对象，不要理解为定义变量
void proc1(int a) {
	m.lock();
	cout << "proc1函数正在改写a" << endl;
	cout << "原始a为" << a << endl;
	cout << "现在a为" << a + 2 << endl;
	m.unlock();
}

void proc2(int a) {
	m.lock();
	cout << "proc2函数正在改写a" << endl;
	cout << "原始a为" << a << endl;
	cout << "现在a为" << a + 1 << endl;
	m.unlock();
}
int main() {
	int a = 0;
	thread t1(proc1, a);
	thread t2(proc2, a);
	t1.join();
	t2.join();
	return 0;
}
```

使用`lock_guard`接管`mutex`：这种锁的优点是**可以在作用域执行完后自动解锁**，这样就不需要担心忘了解锁导致线程一直占用资源了。它还可以在构造时**指定`adopt_lock`标识符**，这表示**不再自动上锁**（但还是会自动解锁），所以要**手动上锁**。

```cpp
#include<iostream>
#include<thread>
#include<mutex>
using namespace std;
mutex m;//实例化m对象，不要理解为定义变量
void proc1(int a) {
	lock_guard<mutex> g1(m);//用此语句替换了m.lock()；lock_guard传入一个参数时，该参数为互斥量，此时调用了lock_guard的构造函数，申请锁定m
	cout << "proc1函数正在改写a" << endl;
	cout << "原始a为" << a << endl;
	cout << "现在a为" << a + 2 << endl;
}//此时不需要写m.unlock(),g1出了作用域被释放，自动调用析构函数，于是m被解锁

void proc2(int a) {
    // 通过使用{}来调整作用域范围，可使得m在合适的地方被解锁
	{
		lock_guard<mutex> g2(m);
		cout << "proc2函数正在改写a" << endl;
		cout << "原始a为" << a << endl;
		cout << "现在a为" << a + 1 << endl;
	}
    {
        // 不再自动上锁，但作用域结束还是会自动解锁
        lock_guard<mutex> g(m, adopt_lock);
        m.lock();
        
        cout << "locked" << endl;
    }
	cout << "作用域外的内容3" << endl;
	cout << "作用域外的内容4" << endl;
	cout << "作用域外的内容5" << endl;
}
int main() {
	int a = 0;
	thread t1(proc1, a);
	thread t2(proc2, a);
	t1.join();
	t2.join();
	return 0;
}
```

然后是功能最全面的`unique_lock`，它有`lock_guard`的全部功能，此外还**可以手动上锁解锁**，以及可以**使用`try_to_lock`尝试上锁**，如果是**已上锁状态，代码也会继续向下执行**，所以得配合`if`使用；以及`defer_lock`，表示**默认不上锁**。

```cpp
#include<iostream>
#include<thread>
#include<mutex>
using namespace std;
mutex m;
void proc1(int a) {
	unique_lock<mutex> g1(m, defer_lock);//始化了一个没有加锁的mutex
	cout << "xxxxxxxx" << endl;
	g1.lock();//手动加锁，注意，不是m.lock();注意，不是m.lock(),m已经被g1接管了;
	cout << "proc1函数正在改写a" << endl;
	cout << "原始a为" << a << endl;
	cout << "现在a为" << a + 2 << endl;
	g1.unlock();//临时解锁
	cout << "xxxxx" << endl;
	g1.lock();
	cout << "xxxxxx" << endl;
}//自动解锁

void proc2(int a) {
	unique_lock<mutex> g2(m, try_to_lock);//尝试加锁一次，但如果没有锁定成功，会立即返回，不会阻塞在那里，且不会再次尝试锁操作。
	if (g2.owns_lock()) {//锁成功
		cout << "proc2函数正在改写a" << endl;
		cout << "原始a为" << a << endl;
		cout << "现在a为" << a + 1 << endl;
	} else { //锁失败则执行这段语句
		cout << "" << endl;
	}
}//自动解锁

int main() {
	int a = 0;
	thread t1(proc1, a);
	t1.join();
	//thread t2(proc2, a);
	//t2.join();
	return 0;
}
```

`unique_lock`还可以进行控制权的转移：

```cpp
mutex m;
{  
    unique_lock<mutex> g2(m,defer_lock);
    unique_lock<mutex> g3(move(g2));//所有权转移，此时由g3来管理互斥量m
    g3.lock();
    g3.unlock();
    g3.lock();
}
```

最后是`condition_variable`，它实际上是用来**同步线程**的。使用这种锁我们**可以根据条件随机唤起另一个线程**，就像用`flag`标记一样。关于它的使用可以参考生产者消费者模型的内容。

##### 异步线程

这部分内容看起来和`JS`的`Promise`有异曲同工之处。

首先是**`async与future`**，`async`是一个函数模板，而`future`是一个**占位对象**，当结果**计算出来时它才会有值存在**。和`async/await`一样，在**拿到结果前后面的代码都会被阻塞住**。需要注意的是`future`对象只能**调用一次`get`来获取数据**，再次调用就会报错。

```cpp
#include <iostream>
#include <thread>
#include <mutex>
#include<future>
#include<Windows.h>
using namespace std;
double t1(const double a, const double b) {
	double c = a + b;
	Sleep(3000);//假设t1函数是个复杂的计算过程，需要消耗3秒
	return c;
}

int main() {
	double a = 2.3;
	double b = 6.7;
	future<double> fu = async(t1, a, b);//创建异步线程线程，并将线程的执行结果用fu占位；
	cout << "正在进行计算" << endl;
	cout << "计算结果马上就准备好，请您耐心等待" << endl;
	cout << "计算结果：" << fu.get() << endl;//阻塞主线程，直至异步线程return
	//cout << "计算结果：" << fu.get() << endl;//取消该语句注释后运行会报错，因为future对象的get()方法只能调用一次。
	return 0;
}
```

`shared_future`，它的功能和`future`是一模一样的，只不过`future`只能获取一次数据，**`share_future`可以多次获取数据**（因为它是复制结果）。这也就意味着**`shared_future`可以被多个线程调用**，而**`future`只能被一个线程使用**。

##### 原子类型

有时候我们只想**保护一个变量**不受多线程访问干扰，但又**不想各种上锁解锁**，这时就可以用到**原子类型**。`std::atomic<bool> var`可以构造一个原子类型的对象，这个对象会**自动加上上锁解锁的操作**。但要注意，只有**符合原子操作**的情况**才能进行保护**，比如各种操作符，因为类内部是重载了的。

```cpp
//原子类型的简单使用
std::atomic<bool> b(true);
b = false;
```

##### 生产者消费者模型

这是多线程非常经典的解决方案。核心思路是**生产者不断生成新数据**，如果**达到上限就使用`condition_variable`将生产者线程阻塞**，并**唤起消费者**；**消费者不断消费数据**，如果**消耗完毕就使用`condition_variable`将消费者线程阻塞，并唤起生产者**。

```cpp
#include<iostream>
#include<thread>
#include<mutex>
#include<queue>
#include<condition_variable>


using namespace std;

//缓冲区存储的数据类型
struct CacheData {
	//商品id
	int id;
	//商品属性
	string data;
};

queue<CacheData> Q;
//缓冲区最大空间
const int MAX_CACHEDATA_LENGTH = 10;
//互斥量，生产者之间，消费者之间，生产者和消费者之间，同时都只能一个线程访问缓冲区
mutex m;
condition_variable condConsumer;
condition_variable condProducer;
//全局商品id
int ID = 1;

//消费者动作
void ConsumerActor() {
	unique_lock<mutex> lockerConsumer(m);
	cout << "[" << this_thread::get_id() << "] 获取了锁" << endl;
	while (Q.empty()) {
		cout <<  "因为队列为空，所以消费者Sleep" << endl;
		cout << "[" << this_thread::get_id() << "] 不再持有锁" << endl;
		//队列空， 消费者停止，等待生产者唤醒
		condConsumer.wait(lockerConsumer);
		cout << "[" << this_thread::get_id() << "] Weak, 重新获取了锁" << endl;
	}
	cout << "[" << this_thread::get_id() << "] ";
	CacheData temp = Q.front();
	cout << "- ID:" << temp.id << " Data:" << temp.data << endl;
	Q.pop();
	condProducer.notify_one();
	cout << "[" << this_thread::get_id() << "] 释放了锁" << endl;
}

//生产者动作
void ProducerActor() {
	unique_lock<mutex> lockerProducer(m);
	cout << "[" << this_thread::get_id() << "] 获取了锁" << endl;
	while (Q.size() > MAX_CACHEDATA_LENGTH) {
		cout <<  "因为队列为满，所以生产者Sleep" << endl;
		cout << "[" << this_thread::get_id() << "] 不再持有锁" << endl;
		//对列慢，生产者停止，等待消费者唤醒
		condProducer.wait(lockerProducer);
		cout << "[" << this_thread::get_id() << "] Weak, 重新获取了锁" << endl;
	}
	cout << "[" << this_thread::get_id() << "] ";
	CacheData temp;
	temp.id = ID++;
	temp.data = "*****";
	cout << "+ ID:" << temp.id << " Data:" << temp.data << endl;
	Q.push(temp);
	condConsumer.notify_one();
	cout << "[" << this_thread::get_id() << "] 释放了锁" << endl;
}

//消费者
void ConsumerTask() {
	while(1) {
		ConsumerActor();
	}
}

//生产者
void ProducerTask() {
	while(1) {
		ProducerActor();
	}
}

//管理线程的函数
void Dispatch(int ConsumerNum, int ProducerNum) {
	vector<thread> thsC;
	for (int i = 0; i < ConsumerNum; ++i) {
		thsC.push_back(thread(ConsumerTask));
	}

	vector<thread> thsP;
	for (int j = 0; j < ProducerNum; ++j) {
		thsP.push_back(thread(ProducerTask));
	}

	for (int i = 0; i < ConsumerNum; ++i) {
		if (thsC[i].joinable()) {
			thsC[i].join();
		}
	}

	for (int j = 0; j < ProducerNum; ++j) {
		if (thsP[j].joinable()) {
			thsP[j].join();
		}
	}
}

int main() {
	//一个消费者线程，5个生产者线程，则生产者经常要等待消费者
	Dispatch(1,5);
	return 0;
}
```

#### 不识别转义字符

一个小知识：使用**`R"()"`就能不识别转意字符**，这在访问路径之类的场景是比较有用的。

```cpp
string t = R"(C:\asdf)";
```

#### using类型别名

有时候我们希望定义一个类型在程序中多处使用，这时可以用**C的`typedef`**，也可用**C++的`using`**。另外**命名空间的别名也是可以用`using`的**。

```cpp
int add(int a, int b) {
    return a + b;
}

// add函数类型的别名
typedef int (*ADD)(int, int);

// C++风格的别名
using FUNC = int (*)(int, int);

namespace space {
    // 模板别名，模板类型 using 名称 = 类型;
    template<class T> using ptr = T*;
}

FUNC a = add;
a(1, 2);
```

#### 模板元编程

简单来说，**模板元编程就是把运行时耗时转移到编译时**。这在一些高复杂计算场景是非常有用的，例如递归。利用模板特化机制实现**编译期条件选择结构**，利用**递归模板实现编译期循环结构**，模板元程序则由编译器在编译期解释执行。

因为模板元是编译期就进行优化的，所以它**只能生成常量情况下的代码**（也就解释了为什么OI没有w）。

模板元的优点很明显，运行速度快：

1. 以编译耗时为代价换来卓越的运行期性能（一般用于为性能要求严格的数值计算换取更高的性能）。通常来说，一个有意义的程序的运行次数（或服役时间）总是远远超过编译次数（或编译时间）。

2. 提供编译期类型计算，通常这才是模板元编程大放异彩的地方。

模板元编程技术并非都是优点：

1. 代码可读性差，以类模板的方式描述算法也许有点抽象。

2. 调试困难，元程序执行于编译期，没有用于单步跟踪元程序执行的调试器（用于设置断点、察看数据等）。程序员可做的只能是等待编译过程失败，然后人工破译编译器倾泻到屏幕上的错误信息。

3. 编译时间长，通常带有模板元程序的程序生成的代码尺寸要比普通程序的大，

4. 可移植性较差，对于模板元编程使用的高级模板特性，不同的编译器的支持度不同。

下面来看一段用模板元实现斐波那契数列的程序：

```cpp
#include<iostream>

// 递归模板
template<int N>
struct data {
  	// 使用递归生成循环结构  
	enum a { res = data<N - 1>::a::res + data<N - 2>::a::res };
};

// 特殊模板，递归边界
template<>
struct data<1> {
	enum a {res = 1};
};

template<>
struct data<2> {
	enum a {res = 1 };
};

int getdata(int n) {
	if (n==1 || n==2) {
		return 1;
	} else {
		return getdata(n - 1) + getdata(n - 2);
	}
}

int main() {
	const int myint = 40;
    // 调用模板元
    // 可以用data<myint>::a::res访问，也可以像下面一样简写
	int num = data<myint>::res;//<>内部不可以有变量
	std::cout << num << std::endl;

	std::cout << getdata(40) << std::endl;

	std::cin.get();

	return 0;
}
```

#### 静态断言和常用宏

静态断言可以帮助我们**在编译期间就确定错误**，还可以**定义编译器报错提示**：

```cpp
// 要包含这个头文件
#include <assert.h>

char num = 10;
// 如果这里num是4个字节以上的变量，就报错
static_assert(sizeof(num) >= 4, "类型错误!")；
```

下面这些宏变量可以帮助我们快速定义错误位置：

```cpp
cout << __FILE__ << endl;
cout << __LINE__ << endl;
cout << __DATE__ << endl;
cout << __TIME__ << endl;
cout << __FUNCTION__ << endl;
```

#### union共用体

共用体和结构体和类是类似的，先来说说结构体的大小怎么算...结构体的大小并不是几个类型的变量所占字节之和，而是要**考虑字节对齐**的。直接看下面的例子：

```cpp
struct t {
    // 8
	double a;
    // 8
	double b;
    // 4
	int c;
    // 1，占不满4字节，填充为4
	char d;
};

// 8+8+4+4 = 24
sizeof(t); 
```

共用体具备结构体的所有功能，但它**同一时刻只允许一个变量存在，而且全部成员公有，不能更改，不能继承**。所以**它的大小就是内部占空间最大的变量的大小**，比较适用于需要节省内存的情况。

```cpp
union tt {
    double n;
    int i;
}

tt data;
data.i = 20;
// 20
cout << data.i << endl;

data.n = 10.0;

// 未定义的值，因为此时内存被n拿去用了
cout << data.i << endl;

// 8
sizeof(tt);
```

#### C和C++的空指针

C中空指针用`NULL`表示，它**本质上是数字`0`**。C++中空指针用`nullptr`表示，它**能满足我们强类型的需求**。观察下面的代码就能发现二者的区别了：

```cpp
void test(int * p) {
    cout << "num p" << endl;
}

void test(void * p) {
    cout << "void p" << endl;
}

// 调用的是int的，因为NULL就是0
test(NULL);
// 调用void的，因为nullptr能进行强类型检测
test(nullptr);
```

#### 静动态联编

这是一些概念性的知识。**联编指一个程序模板、代码间互相关联的过程**，它又分为静态联编和动态联编两种。

1. **静态联编**：是**程序的匹配、连接在编译阶段实现**，也称为早期匹配。一些常量、重载、`#define`条件表达式等都是静态联编时完成的。
2. 动态联编：是**程序联编推迟到运行时进行**，所以也称晚期联编。需要程序运行时动态生成的代码，比如`if/switch`等，就时动态联编时完成。

#### 输入输出流（IO系统)

C++中IO操作的所有方法都是**基于`streambuf`和`ios`类**的（两者平行）。**`streambuf`提供对缓冲区的低级操作**，比如设置缓冲区、对缓冲区指针操作、向缓冲区存取字符等；**`ios`类及其派生类则是提供使用流类的接口**，对`streambuf`的缓冲区输入输出进行格式化或非格式化。

##### 四大标准流

这里一共要介绍四个**标准流**（`iostream`）中的类，`cin/cout/cerr/clog`。前两者不用多介绍了，分别用来**从键盘输入和向屏幕输出，而且可以进行文件重定向**；`cerr`用来输出错误，不能文件重定向；`clog`用来向打印机输出。

下面主要演示文件重定向

```cpp
#include <iostream>
using namespace std;

int main() {
    string str;
    cin >> str;
    cout << str;
    return 0;
}

// 在cmd执行命令：./main.exe<"hello world">text.txt
// 这里<是重定向到输入，>就是重定向至指定文件
```

##### get/put

`cin.get`和`cout.put`就是单字符版输入输出。

```cpp
#include <iostream>
using namespace std;

int main() {
    char ch;
   	// 不断读取并输出
    while ((ch = cin.get()) != EOF) {
        cout.put(ch);
    }
    return 0;
}
```

##### geline/write/get

`cin.getline`用来直接**读取一整行字符串**；`cout.write`用来向屏幕**输出指定数量的字符，忽略`/0`**。

```cpp
// 读取一整行，换行结束
string str = cin.getline();

char str[] = "hello world";
// 输出str前五个字符
cout.write(str, 5);
```

关于`cin.getline`和`cin.get`还有点需要注意的地方:

```cpp
// getline是读取一整行，丢掉超出buf部分和指定结束符x之后的字符串
cin.getline(80, buf, 'x');
// get是一次读一个字符，规则和getline是相同的
cin.get(80, buf, 'z');
```



##### 格式化输入输出

这里格式化输出主要是`cin/cout`的格式化输出。和C不一样，C++的格式化都是通过函数来进行的。

输出**八进制和十六进制**：

```cpp
// 直接cout << hex << endl;不会结束输入
// 下个输入会被应用该规则
cout << hex << 100 << endl;
cout << oct << 100 << endl;
```

输出**指定小数点位数**：

```cpp
double db = 3.141592617284;

// 显式十位小数
cout << setprecision(10) << db << endl;
```

**填充字符串**：

```cpp
// 输出20个*
cout.witdh(20);
cout << fill('*');

// 超过设置宽度原样输出，否则填充空格
cout.width(2);
cout << "hello world" << endl;
```

设置**左右对齐**:

```cpp
// 左对齐和右对齐
cout.setf(ios::left);
cout.setf(ios::right);
```

设置**输入实数进制**：

```cpp
// 输入十六进制
cout.setf(ios::hex, ios::basefield);
```

##### 字符串流

C++中提供了一些类帮助我们方便的解析字符串，如果用C语言风格解析会十分麻烦。

**字符串扫描流**，使用`istringstream`类可以创建一个字符串扫描流，通过`>>/<<`操作符进行输入输出，用来**解析空格分离的字符串**非常有用。

```cpp
// 需要包含该头文件
#include <sstream>

string str = "hello world 123 456.7";
string parsed1, parsed2;
int num;
double f;

// 读入字符串
istringstream input(str);
// 按照空格解析
input >> parsed1 >> parsed2 >> num >> f;

//其它符号隔开，可以用replace替换再解析
string str = "hello#world#123#456.7";
str.replace('#', ' ');
```

`ostringstream`就是用来**输出若干个字符串至指定字符串**的。

```cpp
// 需要包含该头文件
#include <sstream>

ostringstream output;

output << "hello" << " world" << 123 << 456.7;

cout << output.str() << endl;
```

`stringstream`是二者的综合，**既可进行读取，也可进行写入**。

```cpp
#include <sstream>

stringstream mystr;

// 插入一个字符
mystr.put('A');

// 插入字符串
mystring << "world";

cout << mystring << endl;

char ch;

// 输出一个字符
mystring >> ch;
```



##### 文件流

用文件流可以通过面向对象的方式操作文件，非常方便。

**输出到文件**，使用`ofstream`类即可。

```cpp
// 文件流头文件
#include <fstream>

ofstream fout;
// 打开
fout.open('./text.txt');
// 写入
fout << "hello world";
// 关闭
fout.close();
```

**从文件输入**，使用`ifstream`。

```cpp
#include <fstream>

// 打开并读取
ifstream fin('./text.txt');

// fin.getline() 按行读取

string file;
// 写入
fin >> file;
fin.close;

cout << file << endl;
```

**文件读入方式**：主要包括`ios::in`之类的这些**模式变量**，用到再查也无妨。

#### STL（略）

因为一定程度上`STL`用的还是比较熟的，而且数据结构容器原理这块看博客肯定比视频详细...所以还是先占坑w

##### map/set的复杂度

C++ 的 `map , multimap , set , multiset` 使⽤红⿊树实现， **插⼊和查询都是 `O(lgn) `的复杂度**， 但 C++11 为这四种模板类提供了（底层哈希实现）以达到 O(1) 的复杂度：

| 散列表类型                | 有⽆关系值 | 接受相同键值 |
| ------------------------- | ---------- | ------------ |
| `std::unordered_set`      |            |              |
| `std::unordered_multiset` |            |              |
| `std::unordered_map`      |            |              |
| `std::unordered_multimap` |            |              |

## C++程序设计语言（特殊版）

> 和JS高程一样，作为书中不知道的知识点的记录...
>
> 稍稍回顾下从开始学到现在的时间线：3月4日开始看视频，大概3月14日看完。开始投简历，有几家爱搭不理的要了简历就没后文了...中间因为要评奖学金，跑学校去了，和老师谈了谈工作的事，他的态度是不要想着这样一意孤行，好好把熟悉的web搞通（全栈）...
>
> 然而大概3月16日左右，室友投过的一个18k企业的hr打电话问了些神必问题（主要还是八股），最后决定3月20号（星期一）下午来个面试。所以虽然老师分析的很多，实际上却没听进去多少，毕竟前端1000:1的面试率，就算搞会全栈又能怎样呢?变成500:1还是干脆就干后端去了呢w....
>
> 然后那周又有个qt的岗发面试，去面qt之前又有个嵌入式岗发面试...这几乎更坚定了全栈不如C++的信念...三个面试一天一个，18k KPI面，没营养；qt只是简单聊了聊qt的槽（面试前想到于是背了w），还有些前端、C++的基础知识；嵌入式岗虽然说是嵌入式，问的却全是C++（而且还有笔试），还比较深入...
>
> 最后qt和嵌入式都发了offer，3月31号（之前时间线似乎提前了一个星期w，实际上是有摆烂一星期），在嵌入式hr嗯没消息的情况下拒了催了三次的qt，主要是没法接受单休，虽然理由说的是米不够...
>
> 好在嵌入式只是因为hr去开会了，下午5点多发了offer...要说嵌入式面了两个半小时，挂掉也确实比较不合理w...当天发offer没仔细看，星期一才接w（星期二就过期了w），顺带谈了谈三方的事，当天就签了三方...
>
> 然后星期三hr突然说4月17号去实习，原本以为三方的7月1号才是ddl的...还给出了一堆学习任务，也就是看书什么的..
>
> 签三方之后就基本没怎么管了，一直在写论文，今天*2023年4月7日16:38:43*上午把论文写完了，所以开始准备学...
>
> 好了，感觉完全流水账，用来写论文可能够，写给自己看的笔记属实惨不忍睹了，有什么想说的后面再记了w...
>
> 还真有想说的w，写了几天论文感觉过了几个星期，上面提到的混乱时间线大概就是因为这个原因...这么一想工作是这个星期敲定的，三方也是，论文也是，时间上跨度的感觉却像过了几个星期，真是烂柯人了...

### 导论

#### 使用成员函数的算法

P85，这里提到了个`mem_fun(&class::func)`函数，它的作用是**取出类中成员的指针，然后生成一个能够调用该类的东西**（书中如此，大概是为了简化）。很像前面提到的[仿函数（引用类内部函数)](#仿函数（引用类内部函数))，下面看看它的用法：

```cpp
#include <iostream>
using namespace std;

class Test {
	public:
		void say() {
			cout << "hello world" << endl;
		}
};

int main() {
  	// 拿到say方法
	auto fun = mem_fun(&Test::say);
	
	Test *t = new Test();
	
    // 调用时需要传入对应的实例
	fun(t);
	return 0;
}
```

感觉可以用来增加通用性？这相当于把某个成员函数当成了一个工厂或者接口，想执行那个实例的方法就传入那个实例就行。反过来也可以，就是得写个`void exec(class t) { t.func(); }`这样的函数了。

### 基本功能

#### 枚举

P70（99），一个是书上的页码，一个PDF的页码。

这里主要阐述了枚举范围、大小等概念，先看代码。

```cpp
#include <iostream>
using namespace std;

enum T{ a = 1, b = 2 };

int main() {
	cout << sizeof(T) << endl; // 4
	
	T t = T(3);
	T t2 = T(100);
    // 范围[0, 2^k - 1]，但是这里不知道为什么没有出现越界的情况
    // 类型错误，T不是int类型
    // T t3 = 3;
	cout << t << ' ' << t2 << endl;
	return 0;
}
```

首先说`sizeof(enum)`得到的是什么：实际上这和`enum`的表示范围机制有关。如果`enum`中存在负数，那么它可以表示`[-2^k, 2^k - 1]`范围的实数，否则就是`[0, 2^k - 1]`。这个`2^k`表示在**最小2的k次方这个范围内，能表示`enum`中所有成员**。上面代码里这个范围应该就是`[0, 2^2 - 1]`，只是不知道为什么下面赋值没有溢出什么的。它的**最大表示范围就是一个`int`，根据不同平台会得到不同大小**。

然后这里没有溢出也可以理解，因为它不能提供编译时的错误提示，那想通过`enum`来做大小限定也是不可能的。

#### 常量

P86（115），一些细节。

用`const`声明的变量，是**字面量就不会分配内存空间，直接用符号表代替**；如果是需要运行时才确定的变量，就不会这样操作。

#### 引用

P89（118），谈谈引用右值。

`const int &t = 1`它看起来是直接引用了一个右值（常量），实际是**引用了一个临时变量**：

```cpp
const int temp = 1;
const int &t = temp;
```

这个临时变量将被一直引用，直到该引用作用域结束。

**在引用变量时，就不会使用这种规则**。这是因为无法确定变量是否在引用前会被销毁，引用这样一个变量的临时变量是非常容易出错的。

#### void类型

这里主要提提`void *`。`void *`是一种可以接受任何类型的指针，但要想使用它，**必须将其转为其它类型**（除了对比操作），转换类型错误，也可能导致奇怪现象。它并不推荐用在高层项目开发中，最大用处是作为不明确类型的函数参数传递。

```cpp
int * test = 1;
double * test2 = 2;
void * t = &test;

cout << *static_cast<int *>(test);
```

#### 匿名命名空间和嵌套使用

发现之前的笔记里没有w，但明明有印象来着...P158（187）。匿命名空间也就是指`namespace {}`这种命名空间。它并不是真的表示命名空间内的成员无法被外部访问了，相反，**如果是匿名命名空间**，那在**其后的代码都可以直接访问内部成员**。原因是`namespace {}`等价于`namespace 某个唯一名字 {}; using namespace 某个唯一名字;`。

命名空间笔记：[命名空间](#命名空间)。

命名空间也可以进行**嵌套使用**（注意是使用，不是声明），它看起来就像命名空间的继承一样，见代码:

```cpp
namespace Person {
    class String;
	String name;
    int age;
    void say();
}

namespace Human {
	void hello();
}

namespace Woman {
    // 在这个命名空间内直接拿到Person和Human的所有方法
    using namespace Person;
    using namespace Human;
    
    // 所以下面这个String不用带上Person::String就能直接使用
    void world(String &);
}

// 定义时还是要用原命名空间，Woman只是对它内部进行引用
void Person::say() {
    cout << "say hello" << endl;
}

void Human::hello() {
    cout << "say world" << endl;
}

// 因为woman引用了Person内部的String，所以声明也不用带上Person::String
void Woman::world(String & name) {
    cout << name << endl;
}
```

关于C++的向后兼容，命名空间也是其中一部分。

`stdio.h`中的标准库函数，相当于`namespace std { void printf(); }; using namespace std;`，而`cstdio`中的，就少了`using namespace std`这个操作。

#### 预编译、编译、链接

P176（205），感觉这部分讲的不是很详细，至少没有眼前一亮的感觉...

关于八股里的各种奇怪名词这里就不提了，书中也没有提到，后续要深入了解再看博客了w（这么一看书知识点不深入就是一个目录，视频怎么样都能学到东西，对于初学而言）。

预编译，就是**将宏之类的处理成代码片段，并根据include引入头文件**（应该还有些别的功能w）。预处理之后的结果被称为**编译单位**。

预编译出来的编译单位就会交给编译器处理。因为程序可能是分文件写的，所以这个过程需要**借助连接器将各个部分约束在一起**。

连接又有**内部连接**和**外部连接**。**内部连接**指某个**变量只在自己所在的编译单位有引用**，**外部连接**就是**在其它编译单位也有引用**。

最常见的外部连接单位**有未被`const/static`修饰的全局变量**，或者**使用`extern`声明的变量**。

外部连接由于其跨文件性，往往可能导致一些奇怪的编译Bug。例如全局变量同名导致**变量冲突**，或者**`extern`的时候把声明写成了定义**。**类**在外部连接时是个例外，只要**它在不同编译单位的定义完全相同，那么不会引起变量冲突**。但这样做很明显是不明智的，因为可能会出现同名重定义的情况。

感觉这些东西都没有一个总结性的结论...

## 深入理解C++11

> C++程序设计语言看不下去了w，因为大部分内容都是学过的，专门花时间查漏补缺效率太低...
>
> 虽说C++11也粗略学了遍，但也只限如此了...实际上看了前面几节感觉属于一种想记点东西，但又觉得太少了情况...

### 标识符和宏

简单提提...

#### \__func__

`__func__`用来标识**当前运行函数或者类的名字**，在调试时有一定用处。它不可用于默认参数。

```cpp
void hello() {
    return __func__;
}

void world() {
    return __func__;
}

cout << hello() << ' ' << world() << endl;
```

#### _Pragma操作符

它还有个宏的版本，`#pragma`。常见的`#pragma('once')`，就是用来标识某个头文件只编译一次，效果等同于`#ifndef HEADER ...`。

`_Pragma`因为是操作符所以可以配合宏使用，更加灵活。例如：`#define GET(x) _Pragma(x)`。

#### \__VA_ARGS__变长参数

像`printf`这种函数，就是用边长参数`...`去实现的。但我们调用时没法用`...`占位，所以就有`__VA_ARGS__`这个宏。

```cpp
#define PR(...) printf(__VA_ARGS__)

// 使用变长参数封装调试方法
#define LOG(...) {\
	fprintf(stderr, "%s: Line %d:\t", __FILE__, __LINE__);\
	fprintf(stderr, __VA_ARGS__);\
	fprintf(stderr, "\n");\
}

int main() {
    
    
}
```

### 成员初始化

#### =原地初始化

C++98中不支持使用`=`直接对成员进行初始化，C++11则支持这个特性，只要不是静态成员就可以用这种方式原地初始化。

```cpp
class CCC {
    public:
    	int a = 10;
}
```

#### 初始化列表

初始化列表是C++11的新特性，可以用在**构造初始化和原地初始化上**，而且支持对数组之类存在多个元素的数据进行初始化。

它还能用来类实例化时设置内部数据。

```cpp
class TTT {
    public:
    	int a{10};
    	int b;
    	
    	TTT(int x): b{x};
}
```

参考：[类成员列表初始化](#类成员列表初始化)。

初始化列表还能在**类型缩窄时给出编译错误**，这也是C++11中唯一一种方式。类型缩窄，并不是简单的将高位类型转为低位的，而是指在**发生类型转换时会导致数据丢失**。

```cpp
// 编译错误
unsigned char a{-1};
```

### 模板

#### 模板默认值

和函数默认值一样，模板也可以有默认值。它的默认值体现在**模板类型和参数类型上**，二者只要指定其一，就能确定不指定类型下编译出来的代码的类型。

**类模板**类型默认值和参数一样，要求**默认值放在最右边**，而函数模板没有这个规定。

```cpp
// U必须放最右边
template<class T, class U = int> class Hello {
    
}

// T不必放最右边，U的参数设置成了char，那它默认就是char
template<typename T = int, typename U> T func(T a, U b = 'A') {
    
}
```

#### 外部模板

其实这是一个优化的概念。我们知道`extern int i`这种表达式是声明`i`为外部变量的。那为什么要声明呢？因为**编译时目标文件会生成两个`i`，它们有各自的内存区**，这样就没法区分该访问那个了。使用`extern`就能将`i`标识为单个的。

外部模板和外部没关系，但参考了这种优化方式。具体来说就是**如果某个模板函数或者类在多处用到**，但**只用到了一种类型**，那它在编译成目标文件时就**不会产生多份**，而是直接**链接到唯一的一份上**。

```cpp
// a.cpp
#include "test.h"

test(1);

// b.cpp
#include "test.h"

// 可能被优化
test(2);
```

实际上是有`extern template`这种做法的，但似乎和下面的强制实例化有关系。

`extern template void fun<int>(int);`，声明一个强制实例化为`int`类型的模板函数。

#### 强制实例化

也就是明确指定一个模板类型，参考：[重载调用规则](#重载调用规则)。

### 类、左右值

#### 继承构造函数

这里的继承构造函数是指**在子类中直接调用父类构造，而不需要重新声明的一种技巧**。它的本质是使用`using`在子类中**隐式**的声明父类指定函数（可以不是构造，用到那个编译时加上那个）。

实际上有点不太明白这个东西的作用，因为要初始化的时候通过**构造函数委托**就行了。

```cpp
class Father {
    public:
    	Father() {
            
        }
    	
    	Father(int i) {
            cout << i << endl;
        }
    
    	// 存在默认参数可能导致多个继承构造，分别对应不同情况下的参数列表
    	Father(int i = 1, int j = 2) {
            
        }
    
		void hello() {
            cout << "hello" << endl;
        }
}

class Son: Father {
    // 隐式声明父类所有构造函数
    using Father::Father;
    
    // 继承父类hello方法，即使子类重载了也会优先电调用父类的
    using Father::hello;
    
    public:
    	void hello() {
			cout << "world" << endl;
        }
}
```

#### 构造函数委托

如果我们有多个构造函数，且其中一些构造函数功能相同，那就可以用**构造函数委托**来简化操作。这实际上是对构造函数重用的一种实现，在C++98中要想实现这种功能需要手动编写一个工具函数。

在子类中调用父类构造应该也是构造函数委托。另外要注意，我们可以使用链式的方式实现构造委托，但不能出现环。

```cpp
class Info {
	public:
    	Info() {
            cout << "i" << endl;
		}
    	
    	// 使用构造函数委托后，不能继续使用列表初始化或者成员列表初始化
    	Info(int x): Info() {
			cout << x << endl;
        }
}
```

#### 右值和移动构造

移动构造是教程里没提到的东西，它和右值息息相关。

老生常谈的左值、右值就不复读了，这里提提将亡值。C++中所有数据都是这三种类型之一。**将亡值**就是字面意思，一个**即将被回收的值就是将亡值**，`move`的返回值，或者函数返回的右值，都可能是将亡值。

移动构造就是利用将亡值的内存，直接把它分配给新的左值。这就意味着**数据间的交互只是内存变化**，**不涉及新的构造和析构**。

```cpp
// getRightVal返回一个右值，我们使用一个右值引用接收，
// 这会让该右值的生命周期（内存)延长至rv被销毁，这个过程不涉及新的构造和析构
RightVal && rv = getRightVal();

// 直接返回右值，这个右值会变成一个将亡值，会触发新的构造和析构
RightVal rrv = getRightVal();

class RT {
    public:
    	// 典型的移动构造函数，取出要赋值的值，然后将中间量（将亡值）设置成空指针
    	RT(RT && rv): r(rv.val) {
            rv = nullptr;
        }
}
```

常量左值引用也可以接受右值，效果是一样的，只是不能修改。另外为什么一定得设计成右值呢？这些功能通过左值也能完成。实际上是因为**左值需要单独构造出来**，在一些用函数返回值的情况下，构造左值会增加程序的复杂度。

`is_rvalue_ reference`、`is_lvalue_reference`、`is_reference`，可供我们判断值是左值还是右值。比如： `cout << is_rvalue_reference::value;`。

`const type &`是万能引用，即可引用左值也可以引用右值；`type &&`只能用来引用右值，加上`const`就没用了，因为它的目的是为了**创建一个要被修改的临时变量的右值版本**。

#### std::move右值转换

`std::move`的作用就是将左值转为一个右值，本质上操作**类似强制类型转换**`static_cast<T&&>(val)`。被它转换出来的右值并**不会失去原有声明周期**，所以不会出现自动析构之类的问题，在使用时也要特别注意。

```cpp
class Moveable {
    public:
    	Moveable(Moveable && mv) {
            mv = nullptr;
        }
}

Moveable a;
// 把左值a转为右值，此时会调用移动构造，但因为原左值生命周期没有结束，所以
// a会变成nullptr
Moveable b(move(a));

// a为空指针，报错
cout << a.i << ' ' << b.i << endl;
```

#### 完美转发和引用折叠

完美转发就是通过函数模板，将**传入参数原封不动的传入给内部执行函数作为参数**。完美转发要做到的效果是参数和执行函数间仿佛不存在函数模板这个代理，这也就意味着不管是传入左值、右值、引用，都要正确识别。

像下面这样简单的写，虽然可以实现转发，但没法区分左右值：

```cpp
template<typename T> void forward(T val) {
    // 直接传入一个右值，还是会触发复制
    really_func(val);
}
```

C++11中通过**引用折叠**解决了这个问题。所谓引用折叠实际上就是在**引用类型和变量类型不同的情况时**，如何进行**引用类型的推导**。它的规则也很简单，只要声明类型或变量类型有一个是左值引用，那就折叠成左值，否则为右值（二者其一为右值引用，另一个不是引用，或者都是右值引用）。

```cpp
int && x = 1;

int & x; // & &&x，折叠成 &x

int && x; // && &&x，折叠成&&x
```

那么结合引用的性质我们知道，如果传入一个左值引用，而函数参数是一个右值引用，那就会被折叠成左值引用；如果传入右值引用，因为参数也是右值引用所以不会变化。也就相当于我们**利用折叠这个性质同时兼顾了左值和右值引用**。需要注意的是，用于完美转发的右值转换是`forward`函数，而不是`move`（实现是类似的，但函数名更加直观）。

```cpp
// 利用折叠机制进行左右值引用转换
template<typename T> void trans(T && val) {
    // 转为右值，如果是左值就还是得到左值
    // 相当于static_cast<T&&>(val);
    // 所以它的作用主要是对右值引用转换的
    // 因为我们前面的val虽然是个右值引用，但实际上接受的是个左值
    // 所以这里还得把左值转为右值
    really_func(forward(val)); 
}

// 那么为什么右值引用会变成左值呢？看下面的调用
int x = 10;
// 没有问题，但x是个左值
// 这个操作在其它情况，比如直接赋值，或者非函数模板的情况下都会报错
// trans<int>(x); 报错，因为int && 和 int不兼容，具体蒙古；trans<int>(10);没问题
trans(x);
```

### POD数据类型

`POD`是`plain old data`的缩写，简单来说它就是**可以在C++和C中安全操作的数据类型**（比如`memset`，`strcpy`之类的）。构造它有两种方式，**平凡类型和标准布局**。这两个概念实际上都是针对类和结构体来的，因为C++内置标准类型大多都是`POD`。

关于如何构造用到再说...

### 非受限联合体

C++11中取消了对联合体的各种约束。现在**联合体内可以存在静态变量和`POD`数据类型了**。这部分内容主要是如果联合体内存在非`POD`类型，那就要自己手写一个结构体的平凡构造（构造析构）。

具体也是，用到再说w...

### 用户自定义字面量

用户自定义字面量可以用来简化诸如函数传参之类的操作。见下面的代码：

```cpp
color a{1, 2, 3, 4};
color b{3, 4, 5, 6};

func(a, b);
```

我们想要操作`color`类型的`a/b`，必须先声明两个`color`出来，然后才能传递给函数使用。用户自定义字面量就是**将创建类型的过程通过操作符重载的方式简化成字面量**。

```cpp
// 重载_C操作符，第一个参数是字符串，第二个是字符串长度
// 具体重载字符串还是实型可以根据参数来
color operator "" _C(const char* col, size_t n) {
    // 解析后返回
    return color{1, 2, 3, 4};
}

// 使用时带上_C后缀
func("1 2 3 4"_C, "4 5 6 7"_C);
```

可以发现这种操作本质上是解析特定标识的字符串（根据参数决定），然后转为需求数据类型。自定义字面量时要注意`"" _C`这中间有个空格，而且建议以`_`开头，避免混淆`L`这种标识符。

### 命名空间和类型别名

#### 内联命名空间

在C++98中不允许直接**在父空间内特化子命名空间模板**，**内联命名空间**就是用来实现这个功能的。

```cpp
namespace father {
    inline namespace son1 {
        struct Node {}
    }
    
    namespace son2 {
        struct Vec {}
    }
}

namespace father {
    // 这种技巧叫做偏特化，应该就是只有一种类型的类模板
    template <> class Test<son2> {}
}
```

#### using别名

这个在之前的笔记已经提过了，这里补充`using`的模板编程用法：

```cpp
// 定义别名的时候同时定义模板，比typedef更加灵活
template<T> using templateMap = std::map<T, string>;
```

#### decltype

`decltype`也是前面提到过的知识，用在`lambda`表达式返回值推导非常有用。基本使用就是`decltype(0) 123`这种形式。

这里要说的是`decltype`配合`typedef/using`实现**类型别名**。它的用法就是`typedef decltype(vec.begin()) vecbegin`这种写法。因为`decltype`是推导出一个类型，所以一定程度上比`auto`还要灵活。

`decltype`并不像用起来那么简单，实际上它是有**四个推导规则**的：

1. 如果`e`是一个**没有带括号**的**标记表达式**或者**类成员访问表达式**，那么拿到的就是**`e`所命名的实体的类型**。如果`e`是一个**重载函数**，会导致**编译出错**。
2. 如果`e`类型为`T`，并且是一个将亡值，那么拿到的类型是`T&&`。
3. 如果`e`类型为`T`，并且是一个**左值**，那么拿到的是`T&`。
4. 上述均不满足，`e`类型为`T`，拿到的就是`T`。

这里要特别注意的就是规则1和3。首先解释什么是**标记表达式**。实际上除了关键字、字面量等数据，所有**程序员所定义的标记都可以称为标记表达式**。接下来从代码看`decltype`的推导规则：

```cpp
// 标记表达式
int a[3];

// 非标记表达式，字面量
a[1] + a[2];

int i = 0;

// int，使用规则1
decltype(i) j;

// int&，此时拿到的不是标记表达式，而是一个左值，应用规则3
decltype((i)) k; // error，int& 未初始化
```

关于`decltype`的一些其它细节：

1. 对于结构体或者类而言，其**成员并不会继承`const/volatile`**。`struct N { int i; }; const N s{ 0 }; decltype(s.i) i = s.i;`。
2. 与`auto`相同，它会**忽略冗余引用**；但`auto`还会忽略`*`，`decltype`不会。

#### 追踪返回类型

在`lambda`那节提到过这种技巧，只不过当成固定写法略过了。

考虑下面的代码：

```cpp
template<typename T, typename U> void getSum(T i, U j, decltype(i + j) & res) {
    res = i + j;
}
```

可以发现`getSum`因为返回值类型不确定，只能使用引用+`decltype`的形式代替返回值。这样做肯定是非常不优雅的，那能不能写成下面的形式呢：

```cpp
template<typename T, typename U> decltype(i + j) getSum(T i, U j) {
	return i + j;
}
```

看起来没问题，但很遗憾，编译器会报错，因为`i/j`在声明时都是没定义的（编译从左到右进行）。

追踪返回类型就是为了解决这种问题而存在的。它包含两个要素`auto`和`-> return_type()`。分开拆解，就是**用`auto`作为返回值占位**，`-> return_type`（一般就是用`decltype`推导）**推导返回值类型**。那么代码就可以写成：

```cpp
template<typename T, typename U> auto getSum(T i, U j) -> decltype(i + j) {
	return i + j;
}
```

### auto范围遍历

也就是`for (auto i: vec);`这种代码，这里主要提提它的两个注意点：

1. 范围遍历拿到的是**解引用后的对象**，而迭代器遍历拿到的是**指针地址**（区别就是`cout << i;`和`cout << *i`）。
2. 必须**确定范围**才能使用范围遍历。`func(int a[]) {}`这里的`int a[]`只是个指针起始地址，没有范围，所以会报错。

### 枚举

枚举是一种基本类型，用来定义数值常量。在C++中，定义常量的方式还有以下几种:

1. `const`，最推荐的定义常量的方式，只是没法像枚举那样作为一个整体分类；
2. `#define`，简单替换代码段