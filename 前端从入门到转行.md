# C++笔记

> *2023年3月3日 17点12分*
>
> 不知是生不逢时还是时运不济，总之打算转行了。在BOSS直聘之类的平台海投了1k份简历，没有任何回应（实际上是有个面试的，然而太拉跨不谈)。
>
> 人或许总是不想跳出舒适区的，本Five也是如此。学C++？那前端不白学了？而且现在都三月份了，四月份之前找不到工作好像很危险？
>
> 各种理由和拖延，终于还是在今天深感无奈，破防了w...对比室友投两天三四场面试，工作室后端同学更大的投递量还是0进展，似乎再这样下去我也会是一样的结局。
>
> 实际上转行的起因并不止是前端嗯投没机会，还有一部分是自己觉得前端技术难度就那样，底层搬砖可能才是常态。
>
> 学习曲度平滑，培训班、应届生大量选择，三年经验当一年用，似乎被淘汰或者原地踏步才是真实写照。
>
> C++在自己印象里则更多是一个喜闻乐见的方向：掉头发、难度大、没人学..既然如此为什么不去学前后端呢？几年前做出的决定现在又要推翻，而且是在这种时间点...但稍微了解后C++确实是一个不错的选择。
>
> 竞争少，技术更迭慢，难度大但企业愿意培养...
>
> 另外对应这个时间点，想到了一句鸡汤：种一棵树最好的时间是十年前，其次是现在。人生何处不青山，趁着还有机会多尝试尝试也未必是一种冒险...

## C++就业课

> 看着是个14年的老视频了，不过语言方面可能无所谓，所以就快速看完再说了...

### 常识

区别于之前JS，C++这玩意是写了半年左右的算法的，所以有些语法就是常识。本着全面的角度，这里也记下来。

1. 命名空间，`using namespace std;`实际上表示下面的所有代码都默认带上`std::`这个命名空间。这算是C++的一种”模块化“，在多人开发时可以避免函数名冲突导致的错误。
2. `class`用来代替`struct`，但内部成员默认为`private`。类似Java，不手动指定就是私有成员变量。
3. 函数声明在C++中更加严谨，函数实现和声明的**参数列表、返回值类型必须完全对应**，否则报错。
4. 更严格的指针类型约束，**不同类型的指针想要进行赋值，必须进行类型转换**。例如`void *p; int * a = (void * p)`，这里如果不强转就会报错。
5. **C++中给指针分配内存，使用`new`而不是`malloc`**。`int *p = new int(10); delete p;`，这是C++推荐的标准写法，它的作用和`int *p = (int *)malloc(sizeof(int)); free(p);`是一样的，但无需引用头文件，还能直接指定初始值。此外`new`和`malloc`虽然作用一样，但本质上是有很大区别的，`new`需要使用`delete`释放内存；`malloc`使用`free`，二者不可混用。
6. `int *arr = new int[10]; delete []arr;`，使用`new`来分配数组空间（动态数组长度）。
7. C++中的**引用变量并不是表示地址，而是表示变量别名**。这也就是说引用和指针实际上没什么关系。`int a = 10; int &c = a;`，这里`c`就是`a`的别名，操作`c`相当于操作`a`（地址相同），所以就可以`void swap(int &a, int &b)`真的能直接改变`int a; int b`的值这种效果。因为这个特性，**引用变量必须要有一个明确的值**。
8. 引用区别与指针，假设我们有两个栈空间`main和func`，在`main`的栈空间中存放变量，通过引用传递给`func`，那`func`是不会产生新的栈空间的。也就是说**引用变量从头到尾都是直接操作本身，不会产生第二份**。另外如果我们只是想把变量传进去使用，那可以用`const &`来将其变为只读的。
9. 对象里的`this`：这个`this`不是JS里的`this`，因此不存在各种奇奇怪怪的指向什么的，它就是一个**指向当前类的指针**（注意是指针），在参数和成员变量重名的时候，就可以用它来明确变量`this->age = age`。

### 杂项

和JS笔记一样，用来记录零碎不成单元的小知识。

1. `volatile`修饰符：它的作用是保证被修饰的变量**不被编译器优化**。那什么样的代码会被优化呢？比如`i +=1; i += 2`这种就可能直接被优化成`i += 3`。那为什么需要禁止优化呢？因为在单片机之类的系统中，程序的走向是可能被电路之类的操作影响的。如果因为这种情况导致优化中代码片段的某些条件改变了，就可能发生错误。（或许解释了为什么嵌入式里全用了这个修饰符）
2. `inline`修饰符：它表示某个函数是内联函数，内联函数的作用就是**直接把函数调用改成调用函数代码体**，也就是`inline void test() { int i = 1; }`的效果和`int = 1`是一样的，调用时就是去执行这一条语句。当函数体代码量比较少时，这样做能提高运行效率。（或许解释了为什么OI选手喜欢这样写）
3. 缺省参数：也就是`void test(int a, int b = 10)`这种写法，`b`就是缺省参数。我们调用时不指定值就默认是10。和JS一样，**缺省参数必须放在参数列表中非缺省参数之前**，否则报错。
4. 函数重载：**函数重载主要是根据参数类型来的，和函数返回值类型无关**。`void a(); void a(int t); void a(char t);`这就是一个重载的关系，`a`函数分别有三个重载，无参、整形参数、字符型参数。但要注意，**如果重载的不同函数调用方式相同（空参函数+剩余参数），就会出错**（重载类型不明确），例如：`void a(); void a(int t = 1);`，这时缺省参数可以不传，直接调用会有两个对应的函数，就会报错。
5. 模板函数：简单来说就是**使用`template <class T>`这种形式来给函数参数类型指定一个泛型**。`template <class T> T add(T a, T b) { return a + b; }`，但注意，调用时不需要指定泛型类型（毕竟是强类型语言），直接使用就行，C++编译器会把对应的函数生成出一份对应的代码。例如：`add(1, 2)`。与普通函数一样，**模板函数也能重载和使用缺省参数**等。
6. 命名空间和静态变量：使用`namespace myspace { void func() {} }`，这样就能创建一个命名空间为`myspace`的作用域了。如果我们写成`namespace {}`这种形式，就是一个匿名的命名空间，所有内部声明的代码都只能在该命名空间内使用，相当于一个和外界隔离的块作用域。`static`关键字也可以限制函数作用域范围，假设我们在`t.cpp`中声明了`static void test() {}`，那这个`test`方法就**只能在`test.cpp`中使用**（因为被提前编译了？）。
7. 类成员保护：一般我们会把类成员变量设置成私有属性，然后使用`getter/setter`间接操作。但如果我们**操作的是一个指针类型，那就要用`const`把`getter`的返回值设置成只读指针了**，否则外界拿到指针地址后还是能直接操作内部成员。
8. 类内部访问外部同名变量：有时会存在类**内部变量和外部变量同名的情况。这时优先会调用类内部的变量**，如果**想要访问外部变量，使用`::outside`就行了，这个`::`是一个关键字**，方法或者变量都适用。
9. `struct`和`class`的区别：在C++中，`struct`用起来和类基本一样，只不过**`struct`内部指明权限操作符，默认为`public`，而`class`默认为`private`**。
10. C++中的类和变量作用域：很简单，**类内部的变量只能通过类来访问**。但区别于C语言，**C++中定义普通外部变量建议在`cpp`文件中定义，这是因为C++中`.h`文件可能会被多处引用，就会照成重复定义**。在`cpp`中定义的变量如果想要引用，可以**使用C的`extern`关键字来完成**，`extern int i`就表示引用外部声明的`i`变量。
11. 构造函数初始化成员变量：C++中可以用`constroctor(int a) { age = a; }`这种方式初始化，也可以用一种叫做**初始化成员列表**的方式对成员变量进行初始化，它的语法是`constructor(): age(10)`，这种方式**还能对`const`修饰的变量进行初始化**，而普通赋值是不行的。注意，**只读成员变量和引用成员变量必须用初始化成员列表的方式进行初始化**，因为它们没法赋值。
12. C/C++混合编译：如果我们**混用了C和C++代码，并且C++代码引用了C代码**，就可能出现**C代码中函数找不到**的问题。原因是**C++进行编译时会改变函数名**，因为C++存在**重载机制**，所以即使是看起来函数名相同的重载函数，在编译后的代码中也是不同名的（使用`nm output.exe`可以查看编译后的代码）。那如何解决呢？很简单，**在C语言代码中使用`extern "C" { void hello() {} } `这种方式**（注意这里有个前提，就是**只能在`.h`中使用，不能在`.c`中使用**，因为这是**C++特有的关键字**）告诉编译器这是一个C语言代码就行了，这样编译后就不会改变函数名了。

### 类的基础知识

其实杂项和常识里就写了一部分，现在发现视频基本是在讲类的内容了，所以单独开一节更好。

#### 类的声明和实现

在C++中，如何对类进行声明以及内部成员定义：

我们可以采用**分文件的方式对类进行编写**，这样项目结构更清晰，代码易于维护。一般使用`.h`对类进行声明，`.cpp`进行实现，当然也可以直接在类里面实现方法。

还是惯例的，直接看代码：

`main.cpp`，主文件，调用`man`类。

```cpp
#include <iostream>
#include "man.h"

using namespace std;

int main() {
    // 在栈里给m分配空间
	man m = man();
    // 使用new在堆里分配空间，需要手动释放空间（调用析构函数）
    man *m2 = new man;
    delete m2;
	m.say_hello();
	m.set_age(10);
    
    // 类本质上是个结构体，所以调用sizeof获得的结果和结构体是一样的
    cout << sizeof(man) << endl;
	
	cout << m.get_age() << endl;
	return 0;
}
```

`man.h`，对`man`类进行声明。

```cpp
#ifndef MAN_H
#define MAN_H

#include <string>
#include <iostream>
using namespace std;

class man {
	private:
		int age;
		string name;
	
	public:
    	// 构造函数，对象实例化时自动调用，不写编译器会自动生成一个
    	man();
    	// 析构函数，对象在内存中被回收时自动调用，不写同样会自动生成，一般用来释放类成员占用内存空间
    	~man();
    
		int get_age();
		
		string get_name();
		
		void set_age(int a);
		
		void set_name(string n);
		
    	// 直接在类中对方法进行编写
		void say_hello() {
			cout << "hello hello how low" << endl;
		}
};
#endif
```

`man.cpp`，对`man`类进行实现。

```cpp
#include "man.h"

// 下面这些简单代码都很可能被编译器优化成inline形式
int man::get_age() {
	return age;
}

string man::get_name() {
	return name;
}

void man::set_age(int a) {
	age = a;
}

void man::set_name(string n) {
	name = n;
}
```

#### 拷贝构造函数

拷贝构造函数也是构造函数的一种，如果我们**将两个实例进行赋值，就会去调用这个构造函数**。和构造函数一样，不写默认会有一个实现。另外要注意，**默认实现是浅拷贝，也就意味着引用类型会共享内存地址**。此外如果我们**手动实现了拷贝构造函数，那编译器就不会执行任何操作**了。

如果一个**实例被作为函数参数使用，则也会触发拷贝函数**。这意味着传递对象给函数，会额外开辟一个新的对象空间。但如果我们**使用引用，就可以避免这个过程**。

如果一个**实例被作为函数返回值使用，则根据不同解释器会有不同结果**，有的解释器会把返回值也完整执行构造、析构、拷贝等，而有的解释器则会省略这些，在实际开发中应当避免这种用法。

```cpp
// h
man(const man &it); 

// cpp
char address[100];
man::man(const char *a) {
    // 初始化address
    strcpy(address, a);
}

// 可以发现拷贝构造函数写法和构造函数是一样的，只不过它的参数是引用类型的自身
man::man(const man &it) {
	cout << "copied" << endl;
	strcpy(address, it.address);
}

void test(man m) {
    cout << 'hh' << endl;
}

// main
int main() {
	char a[] = "abc";
	man m = man(a);
	man m2 = m;
	
    // strcpy深拷贝就不会出现相同引用地址的问题
	m2.set_address("hhh");
	
	cout << m.get_address() << endl;
	cout << m2.get_address() << endl;
    
    // 会触发拷贝构造
    test(m);
    
	return 0;
}
```

这里再提提拷贝构造的本质是什么：我们调用拷贝构造时可能是通过`man m2 = m1`这种形式来的，但实际上**编译器会按`man m2(m1)`这种形式执行**，并且它们的效果是一样的。它们的区别就在于是否使用了赋值操作符`=`，但实际上**`=`并不代表一定会执行拷贝构造**。比如`man m2; m2 = m1`，**这种做法就只是把`m2`赋值成了`m1`，是不会去执行拷贝构造的**。

造成这种区别的原因就是**操作符**，详细内容在操作符重载记录。

#### 不可变对象

在创建实例时，我们可以使用`const`对实例进行修饰，这样它就是一个不可变的对象了。这样做之后，我们就**必须保证方法或者成员不可变**。即使是一个返回常量的方法，也得用`cosnt func() cosnt {}`这种方式进行修饰，主要目的是告诉编译器真的不可变，否则就会报错（解释了为什么排序的操作符重载需要这样写）。

```cpp
// h
// 这里返回值不需要加const修饰，因为int本身就不可变
// 如果是指针之类的引用类型，就需要加上const了
int get_age() const;

// cpp
int man::get_age() const {
	return age;
}

// main
const man m3 = man("asdf");
cout << m3.get_age() << endl;
```

#### 传递对象参数

**直接传递对象参数**，相当于在调用函数的栈空间里**又开辟了一份内存地址**，对象越大，效率越低。所以一般是**传递引用或者指针**，前者不开辟新空间效率最高。

```cpp
// 想要类只读，那就加上const修饰
void test(man &m) {}

void test2(man *m) {
	// 指针是通过->调用内部成员
    m->get_age();
}

int main() {
	man m;
    test(m);
    test2(&m);
    return 0;
}
```

#### explicit关键字

并不是某些网站的筛选关键词w...在C++中，可能会**有些操作能有不止一种方式实现**，比如下面赋值会去调用构造函数（可能是操作符重载的原因），`explicit`关键字就是用来**告诉编译器只能用指定方法调用**的。

```cpp
void man::man(int i) {}

// 这种方式会去调用上面的构造函数，即使看起来完全不像调用构造函数
man m = 1;

// 这样就只能通过调用构造函数的方式初始化了
explicit void man::man(int i) {}
man m = man(111);
```

#### 静态类成员

我们知道，在C语言中，**使用`static`修饰的变量，会在程序创建时生成、程序销毁时回收**，C++也是如此。但C++中还有类的概念，不过实际上**类中的静态成员也是遵循这个法则的，它只是调用时要使用class::static的形式**，所以可以理解成给静态变量加了个作用域，静态成员本身和类是没什么其它关系的。另外**类中的静态变量是单例的**，无论创建多少个实例，静态变量永远只有一个。

```cpp
void test() {
    static int i = 0;
    cout << i << endl;
}

for (int i = 0; i < 10; i++) test(); // i 1-10

class man {
    public:
    	static int t;
    	int hhh = 0;
    	man(int tt) {
            // 这种做法是不允许的，因为静态成员t和man这个类没什么关系，程序启动时就存在了
            // t = tt;
        }
    
    	static void set_t(int i) {
            // 没问题，静态方法可以操作静态成员
            t = i;
            // 不行，因为静态方法在类实例化之前就存在了
            // hhh = i;
        }
}

// 这样做是没问题的，man类是否实例化都无所谓，它的作用只是给静态变量加个作用域
man::t = 1;
man::set_t(10);
```

#### 练习：单例模式字符串类

`main.cpp`

```cpp
#include <iostream>
#include "mystring.h"
using namespace std;

int main() {
	// 对应直接传入字符串，调用有参构造 
	mystring *str1 = mystring::makestring("hello world");
	cout << str1->get_str() << endl;
	
	// 对应不传入字符串，使用方法构造
	mystring *str2 = mystring::makestring();
	str2->set_str("hello C++") ;
	cout << str2->get_str() << endl;
	
	// 最后因为是单例模式，所以每次使用时实际是一个mystring对象（str1和str2），这就会导致同时设置再
	// 输出前者会被覆盖
	
	// 然后是清空self，任何一个实例调用都行，实际上不太明白这样做的目的...
	str2->release();
	
	mystring *str3 = mystring::makestring("karam police");
	cout << str3->get_str() << endl; 
	
	return 0;
}
```

`mystring.h`

```cpp
#ifndef MYSTRING_H
#define MYSTRING_H

class mystring {
	private:
        // 注意这里str不是只读的，如果是只读的话其实就只能在构造函数初始化了
		char *str;
		static mystring *self;

		// 单例模式的核心思想：通过禁用构造函数+使用静态变量存放全局实例
	public:
		void set_str(const char *str);
		const char *get_str();

		static mystring *makestring(const char *str = NULL);
		void release();
		
		mystring(const mystring &it);

	protected:
		mystring();
		mystring(const char *);
		~mystring();
};

#endif
```

`mystring.cpp`

```cpp
#include "mystring.h"
#include <cstring>

// 注意初始化的方式，这里static不是类型，是修饰符，所以不能写成 static type var这种形式
mystring *mystring::self = NULL;

// 构造函数，如果makestring有默认参数就用它创建新字符串，否则就用set_str
mystring::mystring(): str(NULL) {

}

// 只有第一次创建self会走到这里，所以直接分配空间就行了 
mystring::mystring(const char *str) {
	const int len = strlen(str);
	this->str = new char[len + 1];
	strcpy(this->str, str);
	this->str[len] = '\0';
}

mystring::~mystring() {
	delete []str;
}

// 创建字符串，单例的核心所在，通过一个静态变量self判断是否存在实例
mystring *mystring::makestring(const char *str = NULL) {
	// self如果为null，就创建一个，后续创建不为null就直接复用 
	if (self == NULL) self = new mystring(str);
	return self;
}

// 如果第一次调用不指定字符串，那就手动使用方法设置 
void mystring::set_str(const char *str) {
	if (self) {
		const int len = strlen(str);
		const int nowLen = strlen(this->str);
		
		// 如果空间不够就重新分配，否则复用
		if (nowLen < len) {
			delete []this->str;
			this->str = new char[len + 1];
			strcpy(this->str, str);
			this->str[len] = '\0';
		} else {
			strcpy(this->str, str);
		}
	}
}

const char *mystring::get_str() {
	return str;
}

void mystring::release() {
	if (self != NULL) {
		delete self;
		self = NULL;
	}
}
```

#### 友元

友元`friend`是C++中的一个特性，它允许我们**通过声明友元变量或者函数，让外部访问类中所有变量（包括私有变量）**。从字面意思上来理解就是声明一个类的朋友，这个朋友不受访问权修饰符的限制。注意**友元是单向一对一的，不存在传递关系**。

```cpp
class demo {
    private:
    	int a = 0;
    
    public:
    	// 友元函数
    	friend void test();
    	// 友元类
    	friend class demo2;
}

class demo2 {
    public:
    	demo2() {
            demo d();
            cout << d.a << endl;
        }
}

void test() {
    demo d = demo();
    // 可以访问
    cout << d.a << endl; 
}
```

#### 操作符重载

前面的拷贝构造函数中我们提出了一个`man m; m = m2`拷贝构造函数没有触发的问题。这是因为这个过程本来就不是调用拷贝构造函数，它实际上是进行了**等号赋值**。如果我们不处理它，会导致下面的问题:

要想解决这个问题，就需要操作符重载了。C++允许我们对除了`?:`、`::`、`.*`、`sizeof`、`.`以外的所有操作符重载。通过重载操作符，我们能**自定义不同操作符下实例执行的操作**。但要注意，**操作符重载只能改变执行行为**，**无法改变优先级、结合性、左右操作数等语言规定**。

操作符重载的语法为`type operator op(const class &name)`，和其它成员函数一样，操作符也允许重载。

```cpp
class demo {
    private:
    	char *str;
    public:
    	~demo() {
            cout << "destoryed" << endl;
            delete []str;
        }
    	demo(const char *s) {
            int len = strlen(s);
            str = new char[len + 1];
            strcpy(str, s);
            str[len] = '\0';
        }
    	demo(const demo &it) {
            // 复制，代码同上
        }
    	
    	// 操作符重载，注意这里返回的是demo类型，如果我们的操作符不需要返回任何东西
   		// 可以直接定义为void
    	// 那为什么要返回demo对象呢?因为可能会有a = b = "hhh"这种情况，这在C++语法
    	// 中是完全没问题的，但如果返回void，就会导致a = b出错；返回this则又会执行
    	// 下面的复制操作，就能实现这种效果了。同理，其它重载也是这样写的。
    	demo operator =(const demo &it) {
            // 复制
            return this;
        }
    	
    	// 重载，直接给实例赋值字符串（代码简化)
    	demo operator =(const char *s) {
			strcpy(str, s);
            return this;
        }
    	
    	// 重载，给实例赋值数字
    	demo operator =(const int n) {
            sprintf(str, "%d", n);
        }
}

int main() {
    demo d1  demo('hhh'), d2;
    // 因为这里只是简单的赋值，所以不会触发拷贝构造，这也就意味着d2和d1是完全相同的
    // 如果d2触发了析构函数，那d1内的字符串也会被清除，即使它还存在引用
    d2 = d1;
    return 0;
}
```



### makefile

#### 基础操作

这块不知道怎么分类，也算比较重要的内容，所以先单独拿出来。

在`windows`平台下，我们可以借助各种开发软件直接对编写好的项目进行编译。但在`Linux`下，是没有这么多的工具的，因此只能通过手动调用`g++`，或者编写`makefile`来实现。一般C/C++程序变成可执行文件是有**编译和链接**两个步骤的，`g++`也遵守这个规则。

C++程序一般**使用`g++`进行编译**，它的两个**常用指令，`-c`和`-o`**，分别是进行**编译和指定输出文件名**。比如`g++ -o main.o -c main.cpp`，就会生成一个`main.o`文件。如果是**单文件**的情况下，那我们**可以直接执行**它；但如果是**多文件**，那么这一步就**只是生成这个文件的C++程序语法结构**。什么意思呢?就是说**它引用的其它文件都是不会参与到这个过程的**，这时直接执行就会报错了。那如何把其它文件加进来呢？也很简单，把其它文件编译，然后通过`g++ -o app main.o test.o`，这种形式就行了，**这一步就是链接**。

`makefile`本身是类似一个脚本语言的工具，通过它我们能编程式的进行编译链接，也就能剩下很多重复工作。下面假设我们有一个`main.cpp`，它引用了`t.h`，编写一个`makefile`来进行编译：

```makefile
// makefile里是可以使用变量的，约定成俗用大写表示变量
CC=g++

// 执行make默认调用这个命令
// 这里后面跟的main.o，t.o表示该命令依赖这两个文件，如果没有就会去执行对应的命令
start: main.o t.o
	// 引用变量，注意这里要用tab缩进，这是语法要求
	$(CC) -o myapp main.o t.o
	
// 生成main和t的目标文件
main.o:
	$(CC) -o main.o -c main.cpp

t.o:
	$(CC) -o t.o -c t.cpp
	
// 清除.o文件，也是约定成俗的，注意它不会自动执行，所以得手动指定要运行这个命令
// 目标文件的生成是根据文件修改日期来的，也就是并不是每次执行都会生成一次，只有没有或者源文件发生改变时才会进行
// 如果项目体量很大，保留目标文件能减少编译时间
clean:
	rm -rf main.o t.o
```

#### 变量简化

上面的代码中有个问题，就是我们每次加入新文件都需要重新写一个配置，这也是老生常谈的问题了，解决方法就是**通过维护变量来省去重复代码**。

```makefile
CC=G++

SRCS=main.cpp\
	 t.cpp

// 这段代码用来生成目标文件，它的意思是把SRCS变量的.cpp替换成.o，这样我们就只需要维护
// SRCS这个变量了
OBJS=$(SRCS:.cpp=.o)

// 最终生成的可执行文件名
EXEC=myapp

start: $(OBJS)
	$(CC) -o $(EXEC) $(OBJS)
	
// 表示对.cpp和.o后缀的文件进行下面的处理
// 在start: $(OBJS)的时候就会调用这个
.cpp.o:
	// 这里的$@和$<都是占位符，我们在编译时实际执行的是 g++ -o obj.o -c obj.cpp
	// 这两个占位符就是把这里的obj.o和obj.cpp取出来填充，这样就不需要每个文件都手写一次了
	$(CC) -o $@ -c $<
	
// 清空.o文件
clean:
	rm -rf $(OBJS)
```

#### C/C++混合使用

想要在C++中调用C语言代码，或者想在C语言中调用C++代码，都是没法直接完成的。但我们可以通过**链接库**来完成两者间的互相调用。具体见下面的代码：

`max.c`，链接库的实现代码。

```c
int main(int a, int b) {
    return a > b ? a : b;
}
```

`makelib`，用来编译动态链接库。

```makefile
// C语言使用gcc编译
CC=gcc

SRCS=max.c

OBJS=$(SRCS.c=.o)

// 在unix平台下，必须使用lib*.so的格式声明链接库
EXEC=libmaxtool.so

start: OBJS
	// fPIC这个参数是创建位置无关的文件，函数位置由调用者确定
	// 什么意思呢?假设我们库里函数起始地址为0x00，然后每各0x20创建一个新函数，那
	// 如果我们调用者的函数也是这样分配空间的，就会照成冲突，不指定位置就能让调用者分配地址了
	$(CC) -o $(EXEC) $(OBJS) -fPIC
	
.c.o:
	$(CC) -o $@ -c $<
```

`mymax.h`，声明`max`函数，函数由链接库实现。

```cpp
#ifndef MYMAX
#define MYMAX

// 这个地方要注意，因为我们函数是要给C/C++调用的，所以要判断当前调用环境
// 如果是C++编译器环境，会有个__cplusplus常量，C编译器则没有，判断它是否定义就能知道语言环境
// 如果是C++编译器环境，因为这是个C语言编写的函数，所以要用extern "C"来保证不会重命名

#ifdef __cplusplus
extern "C" {
#endif
    
int max(int a, int b);
    
#ifdef __cplusplus
}
#endif
    
#endif
```

`makefile`，C++代码的编译程序，需要指定链接库。

```makefile
CC=g++

start: main.o
	// 主要注意这里的-L和-l
	// -L后面接的是链接库的文件路径，.就表示当前路径
	// -l表示链接库的名称，因为unix下默认lib开头，so结尾，所以只需要写中间的名称就行
	$(CC) -o myapp main.o -L. -lmymax
	
main.o:
	$(CC) -o main.o -c main.cpp

	
clean:
	rm -rf main.o t.o
```



