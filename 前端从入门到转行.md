# C++笔记

> *2023年3月3日 17点12分*
>
> 不知是生不逢时还是时运不济，总之打算转行了。在BOSS直聘之类的平台海投了1k份简历，没有任何回应（实际上是有个面试的，然而太拉跨不谈)。
>
> 人或许总是不想跳出舒适区的，本Five也是如此。学C++？那前端不白学了？而且现在都三月份了，四月份之前找不到工作好像很危险？
>
> 各种理由和拖延，终于还是在今天深感无奈，破防了w...对比室友投两天三四场面试，工作室后端同学更大的投递量还是0进展，似乎再这样下去我也会是一样的结局。
>
> 实际上转行的起因并不止是前端嗯投没机会，还有一部分是自己觉得前端技术难度就那样，底层搬砖可能才是常态。
>
> 学习曲度平滑，培训班、应届生大量选择，三年经验当一年用，似乎被淘汰或者原地踏步才是真实写照。
>
> C++在自己印象里则更多是一个喜闻乐见的方向：掉头发、难度大、没人学..既然如此为什么不去学前后端呢？几年前做出的决定现在又要推翻，而且是在这种时间点...但稍微了解后C++确实是一个不错的选择。
>
> 竞争少，技术更迭慢，难度大但企业愿意培养...
>
> 另外对应这个时间点，想到了一句鸡汤：种一棵树最好的时间是十年前，其次是现在。人生何处不青山，趁着还有机会多尝试尝试也未必是一种冒险...

## C++就业课

> 看着是个14年的老视频了，不过语言方面可能无所谓，所以就快速看完再说了...

### 常识

区别于之前JS，C++这玩意是写了半年左右的算法的，所以有些语法就是常识。本着全面的角度，这里也记下来。

1. 命名空间，`using namespace std;`实际上表示下面的所有代码都默认带上`std::`这个命名空间。这算是C++的一种”模块化“，在多人开发时可以避免函数名冲突导致的错误。这里**`::`就是域控制符**。
2. `class`用来代替`struct`，但**内部成员默认为`private`**。类似Java，不手动指定就是私有成员变量。
3. 函数声明在C++中更加严谨，函数实现和声明的**参数列表、返回值类型必须完全对应**，否则报错。
4. 更严格的指针类型约束，**不同类型的指针想要进行赋值，必须进行类型转换**。例如`void *p; int * a = (void * p)`，这里如果不强转就会报错。
5. **C++中给指针分配内存，使用`new`而不是`malloc`**。`int *p = new int(10); delete p;`，这是C++推荐的标准写法，它的作用和`int *p = (int *)malloc(sizeof(int)); free(p);`是一样的，但无需引用头文件，还能直接指定初始值。此外`new`和`malloc`虽然作用一样，但本质上是有很大区别的，`new`需要使用`delete`释放内存；`malloc`使用`free`，二者不可混用。
6. `int *arr = new int[10]; delete []arr;`，使用`new`来分配数组空间（动态数组长度）。
7. C++中的**引用变量并不是表示地址，而是表示变量别名**。这也就是说引用和指针实际上没什么关系。`int a = 10; int &c = a;`，这里`c`就是`a`的别名，操作`c`相当于操作`a`（地址相同），所以就可以`void swap(int &a, int &b)`真的能直接改变`int a; int b`的值这种效果。因为这个特性，**引用变量必须要有一个明确的值**。
8. 引用区别与指针，假设我们有两个栈空间`main和func`，在`main`的栈空间中存放变量，通过引用传递给`func`，那`func`是不会产生新的栈空间的。也就是说**引用变量从头到尾都是直接操作本身，不会产生第二份**。另外如果我们只是想把变量传进去使用，那可以用`const &`来将其变为只读的。
9. 对象里的`this`：这个`this`不是JS里的`this`，因此不存在各种奇奇怪怪的指向什么的，它就是一个**指向当前类的指针**（注意是指针），在参数和成员变量重名的时候，就可以用它来明确变量`this->age = age`。

### 杂项

和JS笔记一样，用来记录零碎不成单元的小知识。

1. **`volatile`修饰符**：它的作用是保证被修饰的变量**不被编译器优化**。那什么样的代码会被优化呢？比如`i +=1; i += 2`这种就可能直接被优化成`i += 3`。那为什么需要禁止优化呢？因为在单片机之类的系统中，程序的走向是可能被电路之类的操作影响的。如果因为这种情况导致优化中代码片段的某些条件改变了，就可能发生错误。（或许解释了为什么嵌入式里全用了这个修饰符）
2. **`inline`修饰符**：它表示某个函数是内联函数，内联函数的作用就是**直接把函数调用改成调用函数代码体**，也就是`inline void test() { int i = 1; }`的效果和`int = 1`是一样的，调用时就是去执行这一条语句。当函数体代码量比较少时，这样做能提高运行效率。（或许解释了为什么OI选手喜欢这样写）
3. **缺省参数**：也就是`void test(int a, int b = 10)`这种写法，`b`就是缺省参数。我们调用时不指定值就默认是10。和JS一样，**缺省参数必须放在参数列表中非缺省参数之前**，否则报错。
4. **函数重载**：**函数重载主要是根据参数类型来的，和函数返回值类型无关**。`void a(); void a(int t); void a(char t);`这就是一个重载的关系，`a`函数分别有三个重载，无参、整形参数、字符型参数。但要注意，**如果重载的不同函数调用方式相同（空参函数+剩余参数），就会出错**（重载类型不明确），例如：`void a(); void a(int t = 1);`，这时缺省参数可以不传，直接调用会有两个对应的函数，就会报错。
5. **模板函数**：简单来说就是**使用`template <class T>`这种形式来给函数参数类型指定一个泛型**。`template <class T> T add(T a, T b) { return a + b; }`，但注意，调用时不需要指定泛型类型（毕竟是强类型语言），直接使用就行，C++编译器会把对应的函数生成出一份对应的代码。例如：`add(1, 2)`。与普通函数一样，**模板函数也能重载和使用缺省参数**等。
6. **命名空间和静态变量**：使用`namespace myspace { void func() {} }`，这样就能创建一个命名空间为`myspace`的作用域了。如果我们写成`namespace {}`这种形式，就是一个**匿名的命名空间**，~~所有内部声明的代码都只能在该命名空间内使用，相当于一个和外界隔离的块作用域~~。**匿名的命名空间，相当于没有命名，在程序中可以直接调用，而不需要使用`namespace::`的形式。**`static`关键字也可以限制函数作用域范围，假设我们在`t.cpp`中声明了`static void test() {}`，那这个`test`方法就**只能在`test.cpp`中使用**（因为被提前编译了？）。
7. **指针类成员保护**：一般我们会把类成员变量设置成私有属性，然后使用`getter/setter`间接操作。但如果我们**操作的是一个指针类型，那就要用`const`把`getter`的返回值设置成只读指针了**，否则外界拿到指针地址后还是能直接操作内部成员。
8. **类内部访问外部同名变量**：有时会存在类**内部变量和外部变量同名的情况。这时优先会调用类内部的变量**，如果**想要访问外部变量，使用`::outside`就行了，这个`::`是一个关键字**，方法或者变量都适用。
9. **`struct`和`class`的区别**：在C++中，`struct`用起来和类基本一样，只不过**`struct`内部指明权限操作符，默认为`public`，而`class`默认为`private`**。
10. **C++中的类和变量作用域**：很简单，**类内部的变量只能通过类来访问**。但区别于C语言，**C++中定义普通外部变量建议在`cpp`文件中定义，这是因为C++中`.h`文件可能会被多处引用，就会照成重复定义**。在`cpp`中定义的变量如果想要引用，可以**使用C的`extern`关键字来完成**，`extern int i`就表示引用外部声明的`i`变量。
11. **构造函数初始化成员变量**：C++中可以用`constroctor(int a) { age = a; }`这种方式初始化，也可以用一种叫做**初始化成员列表**的方式对成员变量进行初始化，它的语法是`constructor(): age(10)`，这种方式**还能对`const`修饰的变量进行初始化**，而普通赋值是不行的。注意，**只读成员变量和引用成员变量必须用初始化成员列表的方式进行初始化**，因为它们没法赋值。
12. **C/C++混合编译**：如果我们**混用了C和C++代码，并且C++代码引用了C代码**，就可能出现**C代码中函数找不到**的问题。原因是**C++进行编译时会改变函数名**，因为C++存在**重载机制**，所以即使是看起来函数名相同的重载函数，在编译后的代码中也是不同名的（使用`nm output.exe`可以查看编译后的代码）。那如何解决呢？很简单，**在C语言代码中使用`extern "C" { void hello() {} } `这种方式**（注意这里有个前提，就是**只能在`.h`中使用，不能在`.c`中使用**，因为这是**C++特有的关键字**）告诉编译器这是一个C语言代码就行了，这样编译后就不会改变函数名了。
13. **命名空间的重命名**：如果某个命名空间过长，**可以使用`namespace h = hello`这种方式重命名**。
14. **访问全局变量**，**`::var`可以用来访问全局变量**，这点在8中已经记录了。

### 类的基础知识

其实杂项和常识里就写了一部分，现在发现视频基本是在讲类的内容了，所以单独开一节更好。

#### 类的声明和实现

在C++中，如何对类进行声明以及内部成员定义：

我们可以采用**分文件的方式对类进行编写**，这样项目结构更清晰，代码易于维护。一般使用`.h`对类进行声明，`.cpp`进行实现，当然也可以直接在类里面实现方法。

还是惯例的，直接看代码：

`main.cpp`，主文件，调用`man`类。

```cpp
#include <iostream>
#include "man.h"

using namespace std;

int main() {
    // 在栈里给m分配空间
	man m = man();
    // 使用new在堆里分配空间，需要手动释放空间（调用析构函数）
    man *m2 = new man;
    delete m2;
	m.say_hello();
	m.set_age(10);
    
    // 类本质上是个结构体，所以调用sizeof获得的结果和结构体是一样的
    cout << sizeof(man) << endl;
	
	cout << m.get_age() << endl;
	return 0;
}
```

`man.h`，对`man`类进行声明。

```cpp
#ifndef MAN_H
#define MAN_H

#include <string>
#include <iostream>
using namespace std;

class man {
	private:
		int age;
		string name;
	
	public:
    	// 构造函数，对象实例化时自动调用，不写编译器会自动生成一个
    	man();
    	// 析构函数，对象在内存中被回收时自动调用，不写同样会自动生成，一般用来释放类成员占用内存空间
    	~man();
    
		int get_age();
		
		string get_name();
		
		void set_age(int a);
		
		void set_name(string n);
		
    	// 直接在类中对方法进行编写
		void say_hello() {
			cout << "hello hello how low" << endl;
		}
};
#endif
```

`man.cpp`，对`man`类进行实现。

```cpp
#include "man.h"

// 下面这些简单代码都很可能被编译器优化成inline形式
int man::get_age() {
	return age;
}

string man::get_name() {
	return name;
}

void man::set_age(int a) {
	age = a;
}

void man::set_name(string n) {
	name = n;
}
```

#### 拷贝构造函数

拷贝构造函数也是构造函数的一种，如果我们**将两个实例进行赋值，就会去调用这个构造函数**。和构造函数一样，不写默认会有一个实现。另外要注意，**默认实现是浅拷贝，也就意味着引用类型会共享内存地址**。此外如果我们**手动实现了拷贝构造函数，那编译器就不会执行任何操作**了。

如果一个**实例被作为函数参数使用，则也会触发拷贝函数**。这意味着传递对象给函数，会额外开辟一个新的对象空间。但如果我们**使用引用，就可以避免这个过程**。

如果一个**实例被作为函数返回值使用，则根据不同解释器会有不同结果**，有的解释器会把返回值也完整执行构造、析构、拷贝等，而有的解释器则会省略这些，在实际开发中应当避免这种用法。

```cpp
#include <iostream>
#include <cstring>
#include "man.h"

using namespace std;

namespace funcspace {
	int (*pointer)(int, int);
}

int add(int a, int b) {
	return a + b;
}

class demo {
	private:
	 	char *str;

	public:
		
		demo(const char *s) {
			int len = strlen(s);
			str = new char[len + 1];
			strcpy(str, s);
			str[len] = '\0';
			cout << "construct" << endl;
		}
		
		demo() {
			cout << "construct" << endl;
			str = new char[100];
		}
//		
		void copy_str(char * &&d) {
			int len = strlen(d);
			str = new char[len + 1];
			strcpy(str, d);
			
			str[len] = '\0';
		}
		
		// 不会触发拷贝构造，不知道为什么w，因为GetDemo确实返回的是右值
//		demo(const demo &&it) {
////			cout << "copy" << it.str << endl;
//			cout << *it.get_str() << endl;
//		}

		void test(const demo &&it) {
//			cout << "test" << it.get_str() << endl;
			cout << &it << endl;
//			cout << it.get_str() << endl;
			strcpy(str, it.get_str());
			
		}

		char * get_str() const {
			return str;
		}
		
		~demo() {
			delete []str;
			cout << "destoryed" << endl;
		}
};

// 根据编译器不同对象返回值也会有不同处理，DevC++里就是直接优化成引用了
// 因为这样所以就不会再触发一次d2.test的拷贝构造，那这样其实有没有左右值引用都一样了
// 因为编译器已经优化了...
demo GetDemo() {
	demo d1("hello");
	cout << &d1 << endl;
	return d1;
}

int main() {
//	const demo d1("hello");
	// 这样写触发的只是简单的赋值，因为GetDemo返回的是个右值，不会触发
	// 拷贝引用
//	demo d2 = GetDemo();
	
	// 这样写可以触发&it拷贝，因为d1是个左值，但还是没法
	// 触发&&it，可能因为匹配不上拷贝构造
//	demo d2 = d1;
//	cout << d2.get_str() << endl;
	
	// 使用右值引用
	demo d2;
	d2.test(GetDemo());
	cout << d2.get_str() << endl;
	
	return 0;
}
```

这里再提提拷贝构造的本质是什么：我们调用拷贝构造时可能是通过`man m2 = m1`这种形式来的，但实际上**编译器会按`man m2(m1)`这种形式执行**，并且它们的效果是一样的。它们的区别就在于是否使用了赋值操作符`=`，但实际上**`=`并不代表一定会执行拷贝构造**。比如`man m2; m2 = m1`，**这种做法就只是把`m2`赋值成了`m1`，是不会去执行拷贝构造的**。

造成这种区别的原因就是**操作符**，详细内容在操作符重载记录。

#### 不可变对象

在创建实例时，我们可以使用`const`对实例进行修饰，这样它就是一个不可变的对象了。这样做之后，我们就**必须保证方法或者成员不可变**。即使是一个返回常量的方法，也得用`cosnt func() cosnt {}`这种方式进行修饰，主要目的是告诉编译器真的不可变，否则就会报错（解释了为什么排序的操作符重载需要这样写）。

```cpp
// h
// 这里返回值不需要加const修饰，因为int本身就不可变
// 如果是指针之类的引用类型，就需要加上const了
int get_age() const;

// cpp
int man::get_age() const {
	return age;
}

// main
const man m3 = man("asdf");
cout << m3.get_age() << endl;
```

#### 传递对象参数

**直接传递对象参数**，相当于在调用函数的栈空间里**又开辟了一份内存地址**，对象越大，效率越低。所以一般是**传递引用或者指针**，前者不开辟新空间效率最高。

```cpp
// 想要类只读，那就加上const修饰
void test(man &m) {}

void test2(man *m) {
	// 指针是通过->调用内部成员
    m->get_age();
}

int main() {
	man m;
    test(m);
    test2(&m);
    return 0;
}
```

#### explicit关键字

并不是某些网站的筛选关键词w...在C++中，可能会**有些操作能有不止一种方式实现**，比如下面赋值会去调用构造函数（可能是操作符重载的原因），`explicit`关键字就是用来**告诉编译器只能用指定方法调用**的。

```cpp
void man::man(int i) {}

// 这种方式会去调用上面的构造函数，即使看起来完全不像调用构造函数
man m = 1;
// 原因是C++确实支持这种初始化方式，比如（但括号只能用来初始化，=则没有这种限制）
int a(10);

// 这样就只能通过调用构造函数的方式初始化了
explicit void man::man(int i) {}
man m = man(111);
```

#### 静态类成员

我们知道，在C语言中，**使用`static`修饰的变量，会在程序创建时生成、程序销毁时回收**，C++也是如此。但C++中还有类的概念，不过实际上**类中的静态成员也是遵循这个法则的，它只是调用时要使用class::static的形式**，所以可以理解成给静态变量加了个作用域，静态成员本身和类是没什么其它关系的。另外**类中的静态变量是单例的**，无论创建多少个实例，静态变量永远只有一个。

```cpp
void test() {
    static int i = 0;
    cout << i << endl;
}

for (int i = 0; i < 10; i++) test(); // i 1-10

class man {
    public:
    	static int t;
    	int hhh = 0;
    	man(int tt) {
            // 这种做法是不允许的，因为静态成员t和man这个类没什么关系，程序启动时就存在了
            // t = tt;
        }
    
    	static void set_t(int i) {
            // 没问题，静态方法可以操作静态成员
            t = i;
            // 不行，因为静态方法在类实例化之前就存在了
            // hhh = i;
        }
}

// 这样做是没问题的，man类是否实例化都无所谓，它的作用只是给静态变量加个作用域
man::t = 1;
man::set_t(10);
```

#### 练习：单例模式字符串类

`main.cpp`

```cpp
#include <iostream>
#include "mystring.h"
using namespace std;

int main() {
	// 对应直接传入字符串，调用有参构造 
	mystring *str1 = mystring::makestring("hello world");
	cout << str1->get_str() << endl;
	
	// 对应不传入字符串，使用方法构造
	mystring *str2 = mystring::makestring();
	str2->set_str("hello C++") ;
	cout << str2->get_str() << endl;
	
	// 最后因为是单例模式，所以每次使用时实际是一个mystring对象（str1和str2），这就会导致同时设置再
	// 输出前者会被覆盖
	
	// 然后是清空self，任何一个实例调用都行，实际上不太明白这样做的目的...
	str2->release();
	
	mystring *str3 = mystring::makestring("karam police");
	cout << str3->get_str() << endl; 
	
	return 0;
}
```

`mystring.h`

```cpp
#ifndef MYSTRING_H
#define MYSTRING_H

class mystring {
	private:
        // 注意这里str不是只读的，如果是只读的话其实就只能在构造函数初始化了
		char *str;
		static mystring *self;

		// 单例模式的核心思想：通过禁用构造函数+使用静态变量存放全局实例
	public:
		void set_str(const char *str);
		const char *get_str();

		static mystring *makestring(const char *str = NULL);
		void release();
		
		mystring(const mystring &it);

	protected:
		mystring();
		mystring(const char *);
		~mystring();
};

#endif
```

`mystring.cpp`

```cpp
#include "mystring.h"
#include <cstring>

// 注意初始化的方式，这里static不是类型，是修饰符，所以不能写成 static type var这种形式
mystring *mystring::self = NULL;

// 构造函数，如果makestring有默认参数就用它创建新字符串，否则就用set_str
mystring::mystring(): str(NULL) {

}

// 只有第一次创建self会走到这里，所以直接分配空间就行了 
mystring::mystring(const char *str) {
	const int len = strlen(str);
	this->str = new char[len + 1];
	strcpy(this->str, str);
	this->str[len] = '\0';
}

mystring::~mystring() {
	delete []str;
}

// 创建字符串，单例的核心所在，通过一个静态变量self判断是否存在实例
mystring *mystring::makestring(const char *str = NULL) {
	// self如果为null，就创建一个，后续创建不为null就直接复用 
	if (self == NULL) self = new mystring(str);
	return self;
}

// 如果第一次调用不指定字符串，那就手动使用方法设置 
void mystring::set_str(const char *str) {
	if (self) {
		const int len = strlen(str);
		const int nowLen = strlen(this->str);
		
		// 如果空间不够就重新分配，否则复用
		if (nowLen < len) {
			delete []this->str;
			this->str = new char[len + 1];
			strcpy(this->str, str);
			this->str[len] = '\0';
		} else {
			strcpy(this->str, str);
		}
	}
}

const char *mystring::get_str() {
	return str;
}

void mystring::release() {
	if (self != NULL) {
		delete self;
		self = NULL;
	}
}
```

#### 友元

友元`friend`是C++中的一个特性，它允许我们**通过声明友元变量或者函数，让外部访问类中所有变量（包括私有变量）**。从字面意思上来理解就是声明一个类的朋友，这个朋友不受访问权修饰符的限制。注意**友元是单向一对一的，不存在传递关系**。

```cpp
class demo {
    private:
    	int a = 0;
    
    public:
    	// 友元函数
    	friend void test();
    	// 友元类
    	friend class demo2;
}

class demo2 {
    public:
    	demo2() {
            demo d();
            cout << d.a << endl;
        }
}

void test() {
    demo d = demo();
    // 可以访问
    cout << d.a << endl; 
}
```

#### 操作符重载

前面的拷贝构造函数中我们提出了一个`man m; m = m2`拷贝构造函数没有触发的问题。这是因为这个过程本来就不是调用拷贝构造函数，它实际上是进行了**等号赋值**。如果我们不处理它，会导致下面的问题:

要想解决这个问题，就需要操作符重载了。C++允许我们对除了`?:`、`::`、`.*`、`sizeof`、`.`以外的所有操作符重载。通过重载操作符，我们能**自定义不同操作符下实例执行的操作**。但要注意，**操作符重载只能改变执行行为**，**无法改变优先级、结合性、左右操作数等语言规定，也无法创建新操作符**。

操作符重载的语法为`type operator op(const class &name)`，和其它成员函数一样，操作符也允许重载。

```cpp
class demo {
    private:
    	char *str;
    public:
    	~demo() {
            cout << "destoryed" << endl;
            delete []str;
        }
    	demo(const char *s) {
            int len = strlen(s);
            str = new char[len + 1];
            strcpy(str, s);
            str[len] = '\0';
        }
    	demo(const demo &it) {
            // 复制，代码同上
        }
    	
    	// 操作符重载，注意这里返回的是demo类型，如果我们的操作符不需要返回任何东西
   		// 可以直接定义为void
    	// 那为什么要返回demo对象呢?因为可能会有a = b = "hhh"这种情况，这在C++语法
    	// 中是完全没问题的，但如果返回void，就会导致a = b出错；返回this则又会执行
    	// 下面的复制操作，就能实现这种效果了。同理，其它重载也是这样写的。
    	demo operator =(const demo &it) {
            // 复制
            return this;
        }
    	
    	// 重载，直接给实例赋值字符串（代码简化)
    	demo operator =(const char *s) {
			strcpy(str, s);
            return this;
        }
    	
    	// 重载，给实例赋值数字
    	demo operator =(const int n) {
            sprintf(str, "%d", n);
            return this;
        }
    
    	// 左边是类的情况下，+只需要一元重载即可
    	demo operator +(const int n) {
            return this;
        }
    
    	// 设置友元函数，重载+操作符
    	friend demo operator +(char *s, demo &it);
    	
    	// class++的int参数是必须有的，即使没有什么意义
    	// ++class就需要实现二元操作符重载了
    	// 这也是二元重载，而且是demo++的意思
    	// 为了区分++demo所以要有个int i占位
    	// 为什么是二元重载呢？因为它是类内部重载的
    	demo operator ++(int i) {
            
        }
    	
    	// 一元重载，表示++demo
    	demo operator ++() {
            
        }
    
    	// demo++，相当于二元操作，所以要定义成友元函数
    	friend demo operator ++(const demo &it, int i);
}

// 二元重载，demo++形式
demo operator ++(const demo &it, int i) {
    
}

// 友元函数一元重载，表示++demo（注意区分demo++的类内部二元重载）
demo operator ++(const demo &it) {
    
}

int main() {
    demo d1  demo('hhh'), d2, d3;
    // 因为这里只是简单的赋值，所以不会触发拷贝构造，这也就意味着d2和d1是完全相同的
    // 如果d2触发了析构函数，那d1内的字符串也会被清除，即使它还存在引用
    d2 = d1;
    // 调用=号时，本质上是执行的这一串代码
    // d2 = d1.operator =(100);
    d3 = d2 = "asdf";
    
    d3 = d3 + 100;
    return 0;
}
```

在上面的例子中，我们使用的**一元操作符重载**，所谓一元实际上指的就是**参数个数**。但大部分操作符，**比如`+`，是需要两个操作数的**，也就需要**二元操作符重载**。而根据**类实例在左边还是右边，又有不同的情况**，具体见下：

1. 如果是`class + class`，或者`class + otherType`，这种情况只需要**一元重载**。因为它**相当于调用`demo.operator +(100)`这种形式**。
2. 如果是`otherType + class`，就需要**二元重载**了，因为`111.operator + (demo)`这种操作是不存在的。而且要注意，因为是**`111`去调用操作符**，所以**操作符重载得在全局定义（但并不是所有用到该操作符的情况都会被重载，而是根据参数类型来判断），而不是类内部**（相当于重新定义了一个`+`的调用场景）。这种方式一般是需要**通过友元+外部操作符重载**实现的，因为需要访问类私有成员。

另外要特别注意，**操作符重载的前提一定是至少有一个自定义类型参数**。为什么呢？因为如果都是基本类型我们可以把`+`改成`*`，把`\`改成`-`，这样编译器就没法正常工作了。

```cpp
class demo {
    private:
    	char *str;
    
    public:
    	// 二元重载，实现111.operator +(class)这种操作
    	friend demo operator +(char *s, demo &it);
}

// 不可以，因为参数全是基本类型
bool operator ==(int a, int b) {
    return a == b;
}

// 外部定义操作符重载函数，像+这种操作符是需要两个操作对象的，所以也称为二元操作符
demo operator +(char *s, demo &it) {
    demo result = demo(s);
    // 这里要访问私有变量，所以得设置友元
    strcat(result.str, it.str);
    return demo;
}
```

有些特殊操作符，比如`new`和`delete`，在重载时是要特别注意的。`new`规定必须接受一个`size_t`类型的参数，返回一个空类型指针；而`delete`规定必须接收一个空类型指针，并且返回值为空（以及二者和`operator`间必须有一个空格，其它操作符是可以省略空格的）。一般是不需要重载这两个操作符的，因为C++自带的就能满足绝大部分场景了。

另外要注意，**`new`即使被重载了，也没法取消原本就有的`new`行为**，也就是我们可以在重载中加入自己的代码，但没法替换原有的`new`逻辑。这具体体现就在**`new`无论是否重载，都会去调用构造和析构函数**。

```cpp
void * operator new(size_t size) {
    // size_t的大小就是sizeof(class) * new class[x] + 4字节
    return (this_type *)malloc(size_t);
}

// new []和delete []也是要单独重载的
void operator delete(void * cls) {
    // 注意强转，这里要把void *转成类指针类型，不然free是不止到释放内存空间大小的
    // 因为void *只是表示一个地址
    free (this_type *)free(cls);
}

// 不会调用构造函数和析构函数
demo d = (demo *)malloc(sizeof(demo));
free(d);

// 使用我们重载后的new，还是会调用构造和析构函数
demo d2 = new demo;
```

#### 左值右值和下标操作符

下标操作符的重载也是比较有意思的，它涉及到了**左值和右值**的概念。那什么是左值，什么是右值呢？简单来说，就是下面两个定义：

1. *左值 (lvalue, locator value)* 表示了一个**占据内存中某个可识别的位置（也就是一个地址）的对象**。

2. *右值 (rvalue)* 则使用排除法来定义。一个表达式不是 *左值* 就是 *右值* 。 那么，右值是一个 *不* 表示内存中某个可识别位置的对象的表达式。

左右值在C++11是一个比较重要的概念，但**区分它并不是字面上根据`=`号左右就行**。参考文章：[理解 C/C++ 中的左值和右值 | nettee 的 blog](https://nettee.github.io/posts/2018/Understanding-lvalues-and-rvalues-in-C-and-C/)。

这里简单做下概括：

1. 左值分为**可修改左值和不可修改左值**，像`const var = 1`，这里的`var`**虽然是一个占据了空间的值，但却不能修改**，所以是不可修改左值。
2. **左值可以转变为右值，但右值不能转变为左值**。`int i = 1, j = 2; int k = i + j;`，这里`i, j, k`都是左值，但**`i + j`表达式**产生的是一个**临时的不可修改值（常量）**，所以就变为了右值。
3. 可**通过引用来使左值变为右值的情况再变回左值**（前提是**该值本身就是左值**，而且这里不是右值变成了左值，因为原值就是左值）。这句话看起来比较绕，假设有这样的函数：`int global = 2; int & func() { return global; }`，它返回的`global`是可以被继续修改的。而如果我们**不返回引用，那`global`就会从左值变成右值**，进而无法修改。

关于C++11的左值右值，这里就先不记录了。

那么了解了这个概念，我们就能明白为什么`arr[i] = 1`这种操作是合法的了，因为它返回的是左值引用。下标操作符的实现原理就是这样。

```cpp
char & operator [](int idx) {
    return str[idx];
}
```

#### 移动构造函数

这是C++11新增的特性（教程里不知道会不会讲到）。在[#左右值和引用](#左右值和引用)遇到了传递对象不触发拷贝构造的问题，当时以为是编译器的优化。实际上原因是我们的类**实现了默认的移动构造函数**。移动构造函数的主要作用就是**使用右值引用，减少拷贝之类的操作创建新内存**。

```cpp
class demo {
	private:
    	int x;
    public:
    	// 可以发现它和拷贝构造的区别就在于一者是做左值引用，另一个是右值引用
    	demo (const demo &&it): x(10) {
            cout << "moving" << endl;
        }
}

demo d1;
// 会触发拷贝构造，因为它不是一个右值
test(d1);

// 会触发移动构造，因为函数返回的是一个右值
test(GetDemo());

// 将d1变成右值，也会触发移动构造
move(d1);
```

#### 匿名类

匿名类就是**没有类名的类**。这种类**无法实例化**，也**不需要实例化就能调用内部成员**，实际上是结构体的一种。

```cpp
class {
    public:
		void say() {
            cout << "hello world" << endl;
        }
} notitle;

// 不需要实例化就能调用内部成员
notitle.say();
```

#### const和mutable

我们知道如果**把类实例用`const`修饰**，那它调用的**成员函数也得写成`type name const {}`这种形式**。这是为什么呢？实际上这里这个`const`是**告诉编译器这个成员函数不会修改成员变量**，相当于**把函数体里的内容限定为了只读**（可以理解成减少副作用）。

那如果我们需要**修改某个成员变量呢**？这时就需要用到**`mutable`关键字**了。它的作用就是告诉编译器可以对这个成员进行修改。

```cpp
class demo {
    private:
    	char *name;
    	int age;
    	mutable string address;
    public:
    	void say() const {
            cout << this->name << ' ' << this->age << endl;
 			// 报错，因为函数体内部只能为只读操作
            this->age = 10;
            // 用mutable修饰的成员可修改
            this->address = "hubei wuhan";
		}
}
```

#### 类嵌套实例构造析构顺序

这部分比较类似`Vue`中的声明周期的概念。假设我们在一个类中**嵌套了另一个类的实例**，那它们的**构造函数和析构函数的执行顺序**是怎么样的呢？**一般是最先构造嵌套的类，最后析构嵌套的类；最先析构包含的类，最后构造包含的类**。

其实简单来理解，为什么嵌套类实例反而是最先被构造的呢？因为**包含类中可能会有需要访问嵌套类的代码**，那如果**先实例化了包含类**，就可能出现**包含类访问嵌套类时嵌套类还没初始化**；同理，释放时也得**先释放包含类**，因为**先释放嵌套类**可能**导致需要用到嵌套类的地方访问出错**。

```cpp
class son {
    public:
        son() {
            cout << "son constructor" << endl;
        }
        ~son() {
            cout << "son destoryed" << endl;
        }
}

class father {
    public:
    	son s;
    	
    	father() {
            cout << "father constructor" << endl;
        }
        ~father() {
            cout << "father destoryed" << endl;
        }
}

// son constructor
// father constructor
// father destoryed
// son destoryed
```

#### 禁用默认构造

根据前面的知识我们知道，如果**不声明构造函数，编译器会帮我们自动生成一个**。在某些情况下，我们不想因为默认构造产生意外的结果，比如**禁用拷贝构造从而不允许其它人获取实例值**，此时就可以禁用构造函数。

一般而言，编译器会帮我们**自动生成下面几种构造**：

1. 构造函数
2. 析构函数
3. 拷贝构造
4. 重载`=`运算符

在声明时使用`class() = delete;`的语法就行了。

```cpp
class demo {
	public:
	   	// 显式声明默认构造函数
   		demo() = default;
    	// 禁用默认拷贝构造函数
    	demo(const demo &) = delete;
}
```

#### 类中成员的内存分析

感觉就是个概念w，所以就简单复制粘贴了..

```cpp
//类中的普通成员变量
//类名 变量名  //栈上
//类名 *指针名 =new  类名   //堆上
//类的静态成员  静态区
//成员函数，静态函数都在代码区，类的函数都是共享
//myclass myclass1(10, 9);
//int a(5);
```
#### 继承

继承也是面向对象的经典内容了，在C++里**支持单继承和多继承**，后者使用会相对较少，因为可能产生带环有向图。

##### 单继承

不管是单继承还是多继承，都可以通过**权限修饰符控制派生类访问基类的成员变量权限**，但**无论那种修饰符**，**子类实例都不能直接访问父类`private`成员，除非使用友元**（注意这里说的是实例，类内部还是能自由访问除了`private`以外的所有成员的）。

权限修饰符在继承上和类成员是一致的，`public`权限最高，`protected`其次，`private`最低。

**使用`public`修饰符**，相当于**没对基类权限做修改**（可访问基类中`public`变量）；**使用`protected`**，相当于**把基类中`public`变量变成`protected`的**；使**用`private`**则是**把`protected`和`public`都变成`private`的**。

这些权限操作符除了**控制实例访问权限**，还能**控制继承代数**：

1. `public`，因为不会改变基类成员权限，所以相当于可以**无限继承**（每一代都能访问到基类成员）。
2. `protected`，公有成员变成保护成员，**外部不可直接访问**，但还是可以**无限继承**。
3. `private`，公有和保护成员变成私有成员，**外部不可直接访问**，而且基类成员变成私有后**只能传递一代**。

在**父类和子类间有同名成员的时候**，**类中可以使用`this->father::var`**，**在类外可使用`obj.father::var`的形式访问**。但要注意，这里**即使同名也不会出现重载的情况**，也就是**父类和子类的函数作用域是独立的**。

```cpp
#include <iostream>
using namespace std;

class demo {
	private:
		char *name;

	public:
		int age;

    	static int i;
		static void test() {
			cout << "test" << endl;
		}
    	
    	// 构造函数
        demo(int a): age(a) {

        }

	protected:
		char *address;
};

// 注意要先初始化才能访问
int demo::i = 0;

class son1: public demo {
	public:
    	// 调用父类构造函数
		son1(): demo(1) {
			cout << this->age << this->address<< endl;
            // 访问父类对象
            this->demo::age;
            
            // 子类可以直接访问父类的静态成员
            cout << this->demo::i << endl;
			test();
		}
};

class son2: protected demo {
	public:
		son2(): demo(1) {
			cout << this->age << this->address << endl;
		}

		void t() {
			cout << age << address << endl;
		}
};

// 类内部访问没有限制
class son3: private demo {
	public:
		son3(): demo(1) {
			cout << this->age << this->address<< endl;
		}
};

int main() {
	son1 s1 = son1();
	son2 s2 = son2();
	son3 s3 = son3();
    
    // 如果子类和父类间有重名变量，调用时只能取到子类变量
    // 可以通过这种方式访问父类变量
    cout << s1.demo::age << endl;
	
    // s1只能访问基类的public变量age
    // s2,s3公有分别变成保护和私有变量，所以实例无法访问
	cout << s1.age  << endl;
    
    // 实例也可以直接访问父类静态成员
    son1 *sp = new son1();
	cout << sp->demo::i << endl;
	sp->test();
	
//	s.name;
	return 0;
}
```

##### 多继承和虚基类

多继承和单继承从功能上来说是类似的，都是给子类增加父类的功能。多继承在生命周期上类似类嵌套，**创建时父类优先，销毁时子类优先**。

关于多继承还有个虚基类的概念。我们在实现多继承时，可能会出现**派生三代甚至三代以上的情况**，如果第**三代派生类引用了多个第二代派生类**，并且第**二代派生类有相同基类**，那就可以**用虚基类来优化了**。

看下面的代码，如果我们不声明`Anc`为基类，则**两个子类`A/B`继承时会创建两次`Anc`**，并且因为`C`继承自`A/B`，**还可能出现`Anc`变量语意不明**的情况。所以简单总结，**虚基类可以让被多次引用的基类只创建一次，而且还能消除二义性**。

```cpp
class Anc {
    public:
    	int a;
    	Anc() {
            cout << "anc created" << endl;
        }
    
    	Anc(int x) {
            a = x;
        }
    	~Anc() {
            cout << "anc destoryed" << endl;
        }
}

class A: virtual public Anc  {
    A() {
        cout << "A created" << endl;
    }
    ~A() {
        cout << "B destoryed" << endl;
    }
}

class B: virtual public Anc {
    B() {
        cout << "B created" << endl;
    }
    ~B() {
        cout << "B destoryed" << endl;
    }
}

class C: public A, public B {
    C() {
        cout << "C created" << endl;
    }
    ~C() {
        cout << "C destoryed" << endl;
    }
}
```

#### 类与指针

C++中可以通过指针完成父子类间的互相访问，然而根据情况的不同可能会有各种结果。

##### 普通继承

这种情况是最简单直观的，因为父子指针没有互相调用，就是一个继承的关系。所以结果和继承也是一样的，**子类实例方法和成员会覆盖父类**（意思是调用时同名成员各自调用各自的）。

```cpp
#include <iostream>
using namespace std;

class father {
	public:

		char str[100];

		father(): str("father") {
			cout << "father constructor" << endl;
		}

		void say() {
			cout << "father says" << endl;
		}
};

class son: public father {
	public:
		char str[100];
		son(): str("son") {
			cout << "son constructor" << endl;
		}

		void say() {
			cout << "son says" << endl;
		}
};

int main() {
	father *f = new father;
	son *s = new son;
	
	cout << f->str << endl;
	cout << s->str << endl;
	
	f->say();
	s->say();
	
	return 0;
}
```

##### 父类指向子类（多态）

这种情况**父类依然能正常调用自己的方法**，**不会出现被子类覆盖的情况**。这是为什么呢？我们可以从内存角度思考。把继承关系的内存当成一个盒子，子类从父类继承而来，因此**子类盒子中包含父类内存**。此时去`new son`，相当于**把子类的大盒子空间给父类，因为父类本身就在其中，所以产生交集后拿到的就是自身的内存空间**。

这实际上就是**多态**的体现。

```cpp
father *f = new son;
cout << f->str << endl;
f->say();
```

##### 子类指向父类

这种情况的行为是**无法预知**的，大概率会导致程序崩溃。还是以上面内存盒子的角度思考，子元素盒子中**除了父元素盒子的部分就是自己的内存（成员变量等）**，那此时我们强行将父元素赋值给子元素，就相当于**把子元素自己的空间给抹除了**。这时子元素成员变量之类的**内存地址都是未定义**的，所以去调用就会把程序搞崩。

下面这串代码可能会有不同运行结果，但子类方法大概率是没法运行的。此外我们这里用的是`static_cast`进行类型转换，实际上**用`dynamic_cast`才是符合对象类型转换**的，但它需要用到虚函数，所以先跳过。

准确来说**调用成功否**是**根据子类调用的方法是否引用到了内部数据**来的。如果**没有引用**，比如下面`s->say`，就**没问题**，如果**有引用到**，就会导致**程序崩溃**。

```cpp
father *f = new father;
son *s = static_cast<son *>(f);

cout << f->str << endl;
cout << s->str << endl;

f->say();
s->say();
```

### makefile

#### 基础操作

这块不知道怎么分类，也算比较重要的内容，所以先单独拿出来。

在`windows`平台下，我们可以借助各种开发软件直接对编写好的项目进行编译。但在`Linux`下，是没有这么多的工具的，因此只能通过手动调用`g++`，或者编写`makefile`来实现。一般C/C++程序变成可执行文件是有**编译和链接**两个步骤的，`g++`也遵守这个规则。

C++程序一般**使用`g++`进行编译**，它的两个**常用指令，`-c`和`-o`**，分别是进行**编译和指定输出文件名**。比如`g++ -o main.o -c main.cpp`，就会生成一个`main.o`文件。如果是**单文件**的情况下，那我们**可以直接执行**它；但如果是**多文件**，那么这一步就**只是生成这个文件的C++程序语法结构**。什么意思呢?就是说**它引用的其它文件都是不会参与到这个过程的**，这时直接执行就会报错了。那如何把其它文件加进来呢？也很简单，把其它文件编译，然后通过`g++ -o app main.o test.o`，这种形式就行了，**这一步就是链接**。

`makefile`本身是类似一个脚本语言的工具，通过它我们能编程式的进行编译链接，也就能剩下很多重复工作。下面假设我们有一个`main.cpp`，它引用了`t.h`，编写一个`makefile`来进行编译：

```makefile
// makefile里是可以使用变量的，约定成俗用大写表示变量
CC=g++

// 执行make默认调用这个命令
// 这里后面跟的main.o，t.o表示该命令依赖这两个文件，如果没有就会去执行对应的命令
start: main.o t.o
	// 引用变量，注意这里要用tab缩进，这是语法要求
	$(CC) -o myapp main.o t.o
	
// 生成main和t的目标文件
main.o:
	$(CC) -o main.o -c main.cpp

t.o:
	$(CC) -o t.o -c t.cpp
	
// 清除.o文件，也是约定成俗的，注意它不会自动执行，所以得手动指定要运行这个命令
// 目标文件的生成是根据文件修改日期来的，也就是并不是每次执行都会生成一次，只有没有或者源文件发生改变时才会进行
// 如果项目体量很大，保留目标文件能减少编译时间
clean:
	rm -rf main.o t.o
```

#### 变量简化

上面的代码中有个问题，就是我们每次加入新文件都需要重新写一个配置，这也是老生常谈的问题了，解决方法就是**通过维护变量来省去重复代码**。

```makefile
CC=G++

SRCS=main.cpp\
	 t.cpp

// 这段代码用来生成目标文件，它的意思是把SRCS变量的.cpp替换成.o，这样我们就只需要维护
// SRCS这个变量了
OBJS=$(SRCS:.cpp=.o)

// 最终生成的可执行文件名
EXEC=myapp

start: $(OBJS)
	$(CC) -o $(EXEC) $(OBJS)
	
// 表示对.cpp和.o后缀的文件进行下面的处理
// 在start: $(OBJS)的时候就会调用这个
.cpp.o:
	// 这里的$@和$<都是占位符，我们在编译时实际执行的是 g++ -o obj.o -c obj.cpp
	// 这两个占位符就是把这里的obj.o和obj.cpp取出来填充，这样就不需要每个文件都手写一次了
	$(CC) -o $@ -c $<
	
// 清空.o文件
clean:
	rm -rf $(OBJS)
```

#### C/C++混合使用

想要在C++中调用C语言代码，或者想在C语言中调用C++代码，都是没法直接完成的。但我们可以通过**链接库**来完成两者间的互相调用。具体见下面的代码：

`max.c`，链接库的实现代码。

```c
int main(int a, int b) {
    return a > b ? a : b;
}
```

`makelib`，用来编译动态链接库。

```makefile
// C语言使用gcc编译
CC=gcc

SRCS=max.c

OBJS=$(SRCS.c=.o)

// 在unix平台下，必须使用lib*.so的格式声明链接库
EXEC=libmaxtool.so

start: OBJS
	// fPIC这个参数是创建位置无关的文件，函数位置由调用者确定
	// 什么意思呢?假设我们库里函数起始地址为0x00，然后每各0x20创建一个新函数，那
	// 如果我们调用者的函数也是这样分配空间的，就会照成冲突，不指定位置就能让调用者分配地址了
	$(CC) -o $(EXEC) $(OBJS) -fPIC
	
.c.o:
	$(CC) -o $@ -c $<
```

`mymax.h`，声明`max`函数，函数由链接库实现。

```cpp
#ifndef MYMAX
#define MYMAX

// 这个地方要注意，因为我们函数是要给C/C++调用的，所以要判断当前调用环境
// 如果是C++编译器环境，会有个__cplusplus常量，C编译器则没有，判断它是否定义就能知道语言环境
// 如果是C++编译器环境，因为这是个C语言编写的函数，所以要用extern "C"来保证不会重命名

#ifdef __cplusplus
extern "C" {
#endif
    
int max(int a, int b);
    
#ifdef __cplusplus
}
#endif
    
#endif
```

`makefile`，C++代码的编译程序，需要指定链接库。

```makefile
CC=g++

start: main.o
	// 主要注意这里的-L和-l
	// -L后面接的是链接库的文件路径，.就表示当前路径
	// -l表示链接库的名称，因为unix下默认lib开头，so结尾，所以只需要写中间的名称就行
	$(CC) -o myapp main.o -L. -lmymax
	
main.o:
	$(CC) -o main.o -c main.cpp

	
clean:
	rm -rf main.o t.o
```

### C++语法

从第四天开始看了眼视频暂时不知道怎么分类w，因为这部分似乎就是讲的C++语法...另外发现原来培训班包了差不多四个多月的内容，C++语法只是其中一小部分...

前面类的基础知识肯定也是这一部分的内容，但方便区分就单独放出来。

#### C++和C的区别

1. **C++的类型判断更加严格**，在C里，可以把不同类型的指针直接进行赋值；而在C++中必须通过强转。
2. **C存在变量名全局污染的问题**，C没有命名空间，也没有重载，所以同名函数必然会造成冲突。
3. C++中的`endl`，存在**换行和结束输入的作用**。也就是`cout << "hh"; cout << "ww";`其实相当于`printf("%s%s")`（解释了为什么OI里喜欢把`endl`定义为`\n`）。
4. C没有提供**变量重名的情况下如何访问全局变量的方法**，而C++可以使用`::`访问，这是因为不指定就默认当成全局。
5. C++中要**引用文件作用域的全局变量**，必须明确**使用`extern type var`**，而C默认不需要。
6. **C++引入文件不用`.h`，是为了区分命名空间**。

#### 命名空间

在前面杂项和常识的部分就有关于命名空间的知识了，这里主要是扩展。

1. 命名空间**可以通过重命的形式进行扩展**，但**同名命名空间**内的**变量不可重名**。
2. 命名空间可以进行**嵌套**。
3. **命名空间内一般不写函数，只留一个函数指针**，这样做能够**在功能改动时只修改函数，而不是命名空间**。
4. **命名空间内所有成员都为公有**，而类默认为私有，结构体默认为公有。
5. `using namespace`只能在命名空间后使用，作用域为**下文所有代码（函数内就以块作用域为标准）**。如果**不同命名空间中存在同名变量**，则需要**使用`::`指明使用那个命名空间**。
6. **命名空间常用于迭代开发**，使用命名空间可以一遍编写代码一遍扩展，而不影响其它人。

```cpp
#include <iostream>
using namespace std;

namespace a {
    int i(10);
    
    namespace b {
        int j(20);
    }
}

// 扩展命名空间
namespace a {
    int k (33);
    // 不行，命名空间可重名进行扩展，但内部变量不行
    // int i (10);
}

namespace funcspace {
    // 函数指针
    int (*pointer)(int, int);
}

// 命名空间别名
namespace tt = a;

int add(int a, int b) {
    return a + b;
}

// 在函数中使用
void test() {
    using namespace tt;
    cout << a << endl;
}

using namespace a;
using namespace tt;
int main() {
    // 嵌套使用
    cout << a::i << ' ' << a::b::j << endl;
    
    // 使用函数指针去指明函数功能
    funcspace::pointer = &add;
	cout << funcspace::pointer(1, 20) << endl;
    
    // tt和a里都有a这个变量，所以要明确时那个命名空间在用
    cout << tt::a << endl;
    return 0;
}
```

#### 函数重载的原理与默认参数

在C++中，可以通过**不同参数列表同名函数**的方式进行**函数重载**，那它的原理是什么呢？关键就在于函数的参数列表。我们知道C++函数重载后实际上**函数名是有变化的**，那**如何确定我们调用的是那个函数呢**？答案是**根据参数列表**。**编译器会使用函数参数列表来生成不同地址的函数，传入不同的参数就会调用对应地址的函数**。这也就解释了为什么**函数的重载和返回值无关**。我们可以使用函数指针来验证：

```cpp
#include <iostream>
#include <stdio.h>
using namespace std;

void func(int a) {
    cout << a << endl;
}

void func(double b) {
    cout << b << endl;
}

void func(char c) {
    cout << c << endl;
}

int main() {
    // 拿到不同参数列表的func的函数指针
    void (*f1)(int) = func;
    void (*f2)(double) = func;
    void (*f3)(char) = func;
    
    // 接下来取地址，可以发现不同参数下地址不同
    printf("%p/n", f1); // 0x00
    printf("%p/n", f2); // 0x20
    printf("%p/n", f3); // 0x40
    
    return 0;
}
```

如果想明确使用C语言函数，可以用`extern "C"`来声明（前面提到过），这样就会**用C编译器编译**。

如果函数的**默认参数和函数重载调用形式和调用参数类型是相同**的，那就会报调用不明确的错误：

```cpp
int func(int a, int b = 1, int c = 2) {
    
}

int func(int a) {
    
}

// 报错，因为这种形式既可以匹配上默认参数，也能匹配int重载
func(100);

int func(dobule a) {
    
}

// 没问题，因为可以匹配上double重载
func(100.0);
```

#### 自动类型auto

`auto`可以用来**自动判断变量类型**，它用来遍历数组是非常方便的，不需要指定范围就能遍历整个数组。但是要注意，**`auto`遍历时要保证作用的是一个常量**，它**只能用来遍历一维数组**，因为二维数组取出来的是一个指针，无法确定范围。

```cpp
int arr[2][5] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};

int nums[3] = {1, 2, 3};

// 直接遍历整个数组
for (auto n: nums) {
    cout << n << endl;
}

for (auto data: arr) {
	for (int i = 0; i < 5; i++) {
        // data为一维数组的首地址，访问二维就使用下标的形式
        cout << *(data + i) << endl;
    }
}
```

在**不确定变量类型或者类型写起来很繁琐的情况**下，也可以使用`auto`。C++中还提供了**`typeid(type).name()`这种方式动态获取类型，`decltype(type)`定义类型**。

```cpp
double unknow_type = 0.11;

cout << typeid(unknow_type).name() << endl;

decltype(unknow_type) db(100);
```

#### 左右值和引用

关于左值右值的概念，参考[#左值右值和下标操作符](#左值右值和下标操作符)。这里我们就要探讨引用和左值右值的关系了。首先来看引用和指针。我们知道引用就是给变量起别名，这点在指针上同样适用：

```cpp
#include <iostream>

using namespace std;

int main() {
	int *p = NULL;
	int num = 10;
	
	p = &num;
	
    // 这里&pn就是拿到p的地址引用，加上指针就变成了*p，是一样的效果
	int *(&pn) = p;
	
    // 相当于修改p
	*pn = 114;
	
	cout << *pn << endl;
	return 0;
} 
```

上面这个例子就是左值引用。**左值引用可以减少开辟新的栈空间内存，以及起到变量别名的作用**。此外还有**常引用**，也就是**使用`const`修饰引用**，此时就**可以引用右值了，但只能读取，不能修改**：

```cpp
// 引用右值
const int &ttt = 10;

// 它的原理就是通过一个中间变量存放值，再引用这个变量，这个过程会开辟新的内存空间
const int temp = 10; 
const int &var = temp;
```

右值引用的目的也是提升性能，减少内存消耗。具体来说是**充分利用右值(特别是临时对象)的构造来减少对象构造和析构操作以达到提高效率的目的**。它也是采用**临时变量**的形式实现的，但区别在于**右值引用可修改**。语法`类型 && 引用名 = 右值表达式;`。

下面这个例子展示了右值引用是如何进行构造优化的。这里`demo2`是一个右值引用。（实际上是移动构造优化）

```cpp
#include <iostream>
#include <cstring>
#include "man.h"

using namespace std;

namespace funcspace {
	int (*pointer)(int, int);
}

int add(int a, int b) {
	return a + b;
}

class demo {
	private:
	 	char *str;

	public:
		
		demo(const char *s) {
			int len = strlen(s);
			str = new char[len + 1];
			strcpy(str, s);
			str[len] = '\0';
			cout << "construct" << endl;
		}
		
		demo() {
			cout << "construct" << endl;
			str = new char[100];
		}
//		
		void copy_str(char * &&d) {
			int len = strlen(d);
			str = new char[len + 1];
			strcpy(str, d);
			
			str[len] = '\0';
		}
		
		demo(const demo &it) {
			cout << "copied" << endl;
		}
		
		// 不会触发拷贝构造，不知道为什么w，因为GetDemo确实返回的是右值
//		demo(const demo &&it) {
////			cout << "copy" << it.str << endl;
//			cout << *it.get_str() << endl;
//		}

		void test(const demo it) {
//			cout << "test" << it.get_str() << endl;
			cout << &it << endl;
//			cout << it.get_str() << endl;
			strcpy(str, it.get_str());
//			str = it.get_str();
//			cout << &str << endl;
		}

		char * get_str() const {
			return str;
		}
		
		~demo() {
			delete []str;
			cout << "destoryed" << endl;
		}
};


demo GetDemo() {
	demo d1("hello");
	cout << &d1 << endl;
	return d1;
}

void test(demo& m) {
	cout << m.get_str() << endl;
}

int main() {
//	const demo d1("hello");
	// 这样写触发的只是简单的赋值，因为GetDemo返回的是个右值，不会触发
	// 拷贝引用
//	demo d2 = GetDemo();
	
	// 这样写可以触发&it拷贝，因为d1是个左值，但还是没法
	// 触发&&it，可能因为匹配不上拷贝构造
//	demo d2 = d1;
//	cout << d2.get_str() << endl;
	
	// 使用右值引用，传入
	demo d2;
	d2.test(GetDemo());
	cout << d2.get_str() << endl;
	
	test(d2);
    
    // 右值引用，引用地址（地址是右值）
    int a = 10;
    int * && pt = &a;
	
	return 0;
}
```

引用在和指针配合使用时，可能造成一些难以理解的问题（这里并没遇到堆上的`a`被清除，`r`输出值不同的情况）：

```cpp
#include <iostream>

using namespace std;

int * & test() {
	int *a = new int;
	
	*a = 10;
	
	int * &pa = a;
	
//	*pa = 10;
	
	return pa;
}

int main() {
	int * &r = test();
	
	cout << *r << endl;
	cout << *r << endl;
	
	return 0;
}
```

#### cosnt修饰符

##### 各种用法

C/C++中都有`const`修饰符，然而**C中的`const`其实是没法完全保护变量不可修改的**（因为它是弱类型语言）。

```c
#include <stdio.h>

int main() {
    const int a = 10;
    
    // 虽然类型不相同，但还是允许赋值
    int *p = &a;

    // 成功修改
    *p = 20;
    
    return 0;
}
```

C++则非常严格，只要是**使用`const`修饰的变量，就没法修改**（似乎可以通过注入修改，不过这里还没讲到）。

```cpp
#include <iostream>
using namespace std;

int main() {
    const int a = 10;
    
    // 报错，因为const int和int是不同类型
    int *p = &a;
    
    // 通过强转赋值，不报错但不会成功（*p会改变，但a不会）
    int *p = (int *)&a;
    *p = 20;
    cout << *p << ' ' << a;
    
    // 通过C++的形式去掉const，不报错，但还是无法修改（注意这里的括号）
	int *p = const_cast<int *>(&a);
    *p = 20;
    cout << *p << ' ' << a;
    
    return 0;
}
```

另外C++的`const`还能有多种使用方式（它们的意思可以根据`const`之后修饰变量的位置来区分）：

**指向常量的变量指针**：`const int * var`/`int const * var`，这种两种写法的作用是相同的，意思是**指针指向的是常量**，**不可修改指向的值，但可修改指向的地址**。

```cpp
int a = 10;
int b = 20;
const int * p = &a;

// 不行，指向的是常量
*p = 20;

// 可改变指向地址
p = &b;
```

**指向变量的常量指针**：`int * const p`，这种写法表示**不可修改指向地址，但可修改指向值**。

```cpp
int a = 10;
const int b = 20;

int * const p = &a;
// 可以
*p = 20;

// 不行，不可修改指向地址
p = &b;

// 不行，因为b本身就是常量，没法通过*p2修改
int * const p2 = &b;
```

**指向常量的常量指针**：`const int * const p`这种写法就是**完全只读**的。与其它情况不同，**只读的变量不会作用C++的强类型检测**，而可读或者可写的变量都会有强类型检测，这样做的目的是方便按权限编程。

```cpp
int a = 10;
const int b = 20;

// 没问题，因为p是只读的，所以不会有强类型检测
const int * const p = &a;

const int * const p2 = &b;
```

**常引用**：就和前面解释过的一样，**常引用可以直接引用右值或者保证引用的值无法通过引用修改，但原值仍可修改**。

```cpp
int var = 10;

const int &a = var;
// 不行，因为常引用不能改变引用对象的值
a = 10;
// 可以，因为原引用并不是常量
var = 20;
```

##### 对比#define以及原理

我们知道C中也是可以定义常量的，使用`#define N 100`就行了，但**这实际上并不是常量，也没有类型检测**。因为我们可以**通过重复定义的方式覆盖掉上个定义**。而C++的`const`则解决了这些问题。它的原理是**把常量，比如`100`直接映射成值（`0x64h`），而不是存放在内存中**。这样就保证了**常量一定不可变**，即使我们使用指针去修改了对应地址的值，也不会改变，因为**常量本身就不存放在地址中**。

此外**`const`还会进行自动类型检测**，`const int i = 100.11`，存放的是`100`。而且我们可以把非`const`参数传递给`const`参数，这时值是从内存取的。

```cpp
const int i = 100;

int *p = &i;

// 原地址内的值改变了，但i的值本身就不存放在内存中，所以不会受影响
*p = 200;

void test(const int i) {
    cout << i << endl;
}

int a = 10;
// a不需要定义为const，这里会从内存中取值
test(a);
```

#### new和delete

在C++中，**`new`可以用来给指针在堆上内存**，`delete`则用来**释放内存**。和C的`free`类似，**`delete`也只能释放一次**。

这里要注意，因为我们是使用`new`把内存分配在堆上了，所以**`auto`增强`for`循环是用不了的**，它**只能在栈上使用**。

```cpp
int *t = new int[10];
// 报错
for (auto dd: t) {

}

delete t;
// 程序崩溃
delete t;
```

用`new`分配二维数组内存：

```cpp
// 先把80个元素放一行
int *p = new int[80];
// 再每十个取出来设置成列，这里要强转，把变量名去掉就是类型
// (*px)[10]是个二维数组，每行10列，所以得到的结果就是8行，10列的二维数组
int (*px)[10] = (int(*)[10]) p;
// int (*px)[10] = new int[80]; 不行，因为 new 只能分配线性空间

int d = 0;

for (int i = 0; i < 8; i++) {
    for (int j = 0; j < 10; j++) {
        px[i][j] = d++;
    }
}
```

##### 重载劫持（代理模式）

通过前面的知识我们知道`new`和`delete`重载后要自己设计一个是非常困难的，但我们可以**利用全局的`new`和`delete`完成功能，在这之间添加自己的代码**。比如利用静态变量，统计创建和销毁了多少个实例；或者**将删除后的指针置空**，**防止重复删除导致程序崩溃**。

这种设计技巧甚至可以模拟`Java`的**内存回收机制**（这里跳过）。

```cpp
class demo {
    public:
    	static int count;
    	static void * operator new (size_t size) {
            demo *dpt =::new demo;
            
            cout << "劫持new" << endl;
            
            count++;
            return dpt;
        }
    
    	static void operator delete(void * d) {
            ::delete d;
            // 防止重复delete导致程序崩溃
            d = NULL;
            cout << "劫持delete" << endl;
            count--;
        }
}

int demo::count = 0;
```

##### 构造析构的意义

在上面的代码中，如果我们**使用`new`来创建实例**，会发现**构造和析构函数被执行了两次**。这时因为**构造函数和析构函数只有在有内存空间的情况下才有意义**，所以第一次分配调用一次，真正分配调用一次。

```cpp
demo *d = new demo();
```

##### 全局重载

我们可以通过全局重载的方式来**监听所有对象内存的分配行为**。

```cpp
// size_t无符号整数，因为不能分配负空间内存
void * operator new(size_t size) {
    return malloc(size);
}

void * operator new[](size_t size) {
    return new(size);
}
```

##### 限定区域分配内存

我们直接使用`new`，**内存的地址是由系统决定**的。假如我们想**限定某一块内存分配空间**，就需要用到这种做法了。

这两种用法是有下面的区别的:

1. 如果是**直接使用**不指定内存区，那**指针变量存在栈区**，**存储地址指向堆区**，且需要**手动释放内存**。
2. 如果是**指定内存区**，那**指针变量存在栈区**，**存储地址指向静态区，自动释放内存**。这样做的好处就是**避免内存泄漏**，**自动释放内存**，但缺点就是**牺牲了内存访问的独立性**。

```cpp
const int N(5);
const BUFFER_LEN(500);

char buffer[BUFFER_LEN];

// 自动分配内存
int *p = new int[N];

// 指定内存分配区为buff
int *p2 = new (buffer)int[N];
```

#### 引用高级

先来看两道面试题，要求说明各部分的意义（这种模式在信号编程会用到）：

```cpp
// 把每部分简化再分析
// 最外层
int * T(int, Y);
// T调用的指针函数
int * Y (int);
// 所以可以发现它实际上是一个返回T类型函数指针，参数为int的函数
int (* z(int x, int (*y)(int)))(int);
// 下面这个同理，只是加上了引用
int (* & z(int x, int (* &y)(int)))(int);
```

引用本质上是对变量起别名，那么**别名的类型直接参考原类型**就行，这里以二维数组为例：

```cpp
int a[2][5] = {1, 2, 3, 4, 5, 6, 7, 8, ,9, 10};

// 可以发现就是把变量名a换成了引用&ra，其它部分都是不需要改的
int (&ra)[2][5](a);
```

**引用+函数指针+函数返回值**，会出现令人非常疑惑的代码：

```cpp
#include <iostream>
using namespace std;

int add(int i, int j) {
	return i + j;
}

// 把函数指针作为参数使用
int myadd(int a, int b, int (* &pa)(int, int)) {
	return pa(a, b);
}

// 使用函数改变函数指针的引用
void changeadd(int (* &pa)(int, int)) {
	pa = sub;
}

// 返回一个函数引用，这种情况先简化，再替换类型
// 返回sub类型的指针
int (*& psub(int (*&rp)(int, int)))(int, int) {
	return rp;
}

// 上面这个奇奇怪怪的东西就能返回一个*& (int, int)类型的函数指针引用
// 接下来把它分流程简化下
// 要返回函数指针
// int (*& rp) {}
// 返回函数指针的参数为int, int（注意这里是返回函数指针参数，不是调用函数指针参数）
// int (*& rp)(int, int) {}
// 函数的参数为sub的函数指针，也就是subpoi = int (*&psub)(int, int)
// 组合int (*& rp(subpoi))(int, int) {}
// 最后这个rp就是函数名

// 传入changeadd，再返回changeadd
// 这里的void是返回的调用函数指针类型，不是函数返回值类型
// 返回函数指针类型 void *& rc
// 返回函数的参数int (* &pa)(int, int)，另一个指针函数
// 组合void *& rc(int (* &pa)(int, int))
// 调用函数参数，就是上面的rc
// 调用函数...（感觉这样分析不太公式化，下面给个公式化的操作方法）
void (*& changep(void (* &pa)(int (* &pa)(int, int))))(int (* &pa)(int, int)) {
//	pa = sub;
//	return pa;
	return pa;
}

// 返回函数指针类型 (*& 调用函数名(传入参数))(返回函数指针参数) {
// 
// }

int main() {
	int (*p)(int, int) = add;
	int (* &pa)(int, int) = p;
	cout << myadd(10, 20, pa) << endl;
    
    // 变成了sub
    changeadd(pa);
	cout << pa(10, 20) << endl;
    
    // 大概这样使用
    changep(changeadd)(sub);
}
```

无论是左值引用还是右值引用，都**不能引用一个数组**。因为这样表示数组中每一项都是引用，这在C++中是不允许。

```cpp
int &a = [1, 2, 3];
```

最后，**引用也能使用`const`进行修饰，并且规则和指针是相同的**。参考：[#const修饰符](#const修饰符)。

#### 枚举enum

C和C++中都有枚举类型，但C语言是**弱类型**的，这也就意味着**枚举可以不为同一类型，也可进行重定义**。

```c
// 从0开始，依次递增，但无法限制类型
enum color { red, blue, yellow ,purple = 'P' };
```

C++则更加安全，在声明时我们就**可指定类型，并且无法更改**。

```cpp
// 限定全为char，默认值依然从0开始
enum color: char { red = 'A', blue, yellow, purple };


// 取值
color mycolor = color::purple;
color color2 = purple;

// 报错，只能赋值为限定类型
mycolor = 'A';
```

#### 函数模板

函数模板可以使用**泛型类型指定函数参数类型**，这样我们就不需要编写多个功能相同参数类型的函数来完成功能了。

它的语法是`template<typename T>`，还有之前提到的`template<class T>`，它们意思是一样的。注意，如果我们使用了函数模板，那**参数列表中必须至少有一个模板类型的参数**，否则无法匹配上对应函数。

##### 配合可变参数

这里还要提个新知识：**可变参数**。可变参数就类似`JS`里的剩余参数，能接受**任意数量的位置参数**。但C++中并没有提供那么高层次的封装，所以还得**借助`cstdarg`库来取出可变参数**。

```cpp
#include <cstdarg>

template<typename T>
// ...就是可变参数
T sum(T count, ...) {
    // 存放参数列表的指针
    va_list arg_ptr;
    // 限定从count开始，剩余多少个参数
    va_start(arg_ptr, count);
    T result(0);
    for (int i = 0; i < count; i++) {
        result += va_arg(arg_ptr, T);
    }
    va_end(arg_ptr);
    return result;
}
```

##### auto自动推导

如果我们的模板函数**不止有一个类型**，并且**返回值由这些类型共同决定**，就需要使用`auto`类型来进行推导了。这里要用到一个新语法，`template<typename T, typename N> auto func(T a, N b)->decltype {}`。

```cpp
template<typename T, typename N> auto func(T a, N b)->decltype {
    return a + b;
}

// 使用也用auto声明就行了
auto res = func(1, 1.0);
cout << typeid(res).name() << endl;
```

##### 特殊函数模板

我们前面的写法`template<typename T>`叫做通用函数模板，因为任何类型只要传进去就能使用。但有时候我们想仅仅**针对特定的类型编写函数模板**，就需要用到特殊函数模板了。它的语法是`template<> type func(type){}`，可以发现**和通用函数模板的区别就是没有泛型，类型在参数上明确指明**。

这里还有个小知识，如果类成员**都是公有变量**，那就可以用`{}`的方式进行初始化。

```cpp
class info {
    public:
    	char *name;
    	int age;
}

// 通用模板
template<typename T> void swap(T &t1, T &t2) {
    // ...
}

// 特殊模板，二者虽然用法相同，但如果指明类型会优先调用特殊模板
template<> void swap(info &i1, info &i2) {
    info temp;
    temp = i1;
    i1 = i2;
    i2 = temp;
}

// 都是公有变量，可以这样初始化
info user = {"hwz", 21};
```

##### 重载调用规则

和特殊函数模板的情况类似，有时我们**既有通用函数模板，又有自己写的重载函数**，那此时会去调用谁呢？实际上编译器会对这种情况进行优化，默认是**优先调用重载函数**的。但有时我们就是想要调用通用函数模板，这时就需要**使用`swap<int>`这种方式**了，它表示**将函数模板实例化为`int`类型**。

```cpp
template<typename T>
T add(T a, T b) {
    cout << "T a + b" << endl;
    return a + b;
}

int add(int a, int b) {
    cout << "int a + b" << endl;
    return a + b;
}

// 调用int add
add(1, 2);
// 调用通用函数模板
add(2.1, 2.4);
// 实例化函数模板并指定为int类型，调用函数模板
add<int>(1, 2);
```

##### 通用可变参数模板

在[#配合可变参数](#配合可变参数)这一届节，我们使用可变参数实现了任意数量数相加的函数。但可以发现这种做法比较繁琐，不仅要引入头文件，还得手动指定`count`。

通用可变参数模板可以解决这种问题。它是**将可变参数也作为模板类型**的一种模板。如果我们要使用这种模板，还得**声明一个空函数接口**（只做接口使用，实际调用还是模板函数）。

```cpp
// 空函数接口，必须声明它，否则调用时就会按函数模板匹配
void showall() {}

// 这里...Args是表示一个类型，相当于把...取名为Args了
template<typename T, typename ...Args>
// 而这里的Args ...args就是可变参数了
void showall(T value, Args ...args) {
    cout << value << endl;
	// 递归处理可变参数
    showall(args);
}
```

##### 配合引用包装器

我们知道函数模板可以传入任意类型的参数，这其中包括引用参数。但如果**函数模板的参数不是引用类型**，那我们**即使传入引用也没法修改原值**（因为这时会**变成拷贝参数，地址不同**）。如果函数模板的参数本身就是引用，那我们传入引用就可以正常修改了。

但为了完成这样的功能单独再去重载或者实现一次无疑是非常麻烦的。引用包装器，就是用来解决这种问题的。**引用包装器的语法是`std::ref(变量)`，它可以把一个变量包装成引用类型，函数模板就能正确接收应用了**。

**引用包装器和引用是完全不同的**，如果我们**在普通函数参数上使用引用包装器，那是完全没效果**的，它只有在函数模板这种需要类型推导的情况下才会生效。

```cpp
#include <iostream>
using namespace std;

template<typename T>
void add(T arg) {
	arg++;
}

int main() {
	int cnt = 0;
	int &rcnt = cnt;
	
    // 没有效果
	// add(&cnt);
	// add(rcnt);
		
    // 修改成功
    // 然而不知道为什么编译失败了，这玩意似乎不存在w
    add(ref(cnt));
	cout << cnt << endl;	
	return 0;
}
```

#### inline内联函数

C语言中我们可以使用`#define`来定义一些功能简单的函数，以达到优化的效果。但这样做**无法保证类型安全**，也没法保证函数不被**重定义覆盖**。

C++中则提供了`inline`来解决这个问题。符合`inline`条件的函数在调用时会**直接把函数体执行，而不是入栈新函数**。当然，并不是所有声明为`inline`的函数就会如此，它只是建议编译器这样编译，具体行为得看函数是否满足下面的几个条件：

1. 不能有递归
2. 不能包含静态数据
3. 不能包含循环
4. 不能包含`switch`或者`goto`语句
5. 不能包含数组

如果我们声明的内联函数无法满足上面的条件，就会被当成普通函数处理。

```cpp
// 可以使用函数模板+内联函数实现通用功能
template<typename T>
inline T getSum(T a, T b) {
    return a + b;
}
```

另外在原则上如果我们在类中使用内联函数，只需要将**`inline`定义在头文件里即可**。

```cpp
class demo {
    public:
    	inline void say_hello();
}

// 定义可以不带inline
void demo::say_hello() {
    
}
```

#### C和C++的细节差异

C相对C++而言有些细节上的缺陷，下面就一一列举：

1. **C没法将内存中存在地址的右值自动转为左值**，C++则会**根据右值在内存中是否有实际地址自动转换**。这主要体现在一些**返回右值的表达式**里，`(a = 3)=4; (a ? 1 : 2) = 3;(++a)++;`，这种表达式在C中是非法的，而C++会将右值转为左值。
2. C的**全局变量**存在**定义和声明的区别**，因此**可以声明多次**；C++则不存在这种区别，**只能声明一次**（包括静态全局变量）。全局定义`int a; int a; int a;`在C中是合法的，在C++中就是非法的。
3. **C的函数可以没有返回值**，C++是**强类型系统**，**函数必须有返回类型**。
4. **C的`register`变量无法取地址**；C++编译器会**根据`register`是否有取地址行为决定放不放到寄存器里**。
5. C没有**占位参数**；C++允许占位参数，方便扩展。`void func(int a, double, char) { cout << a; }`，这串代码中`double/char`是没有变量名的，在C中只有声明时可以这样做，而C++允许我们声明这种占位参数，即使编译器不会把这些参数加到函数里。

#### 宽字符本地化

像中文、韩文之类的语言都是使用`utf-8`存储的，~~在C++中不能直接输出它们~~，需要使用**宽字符**。此外还需要注意，只是使用宽字符存放字符串还是不能直接输出，得**设置本地化标志才行**。

```cpp
#include <iostream>
// 本地化标准头文件
#include <locale>

using namespace std;

int main() {
    // 把宽字符的本地化标准设置为简体中文，这样才能正常显示
	setlocale(LC_ALL, "chs");
    // 注意类型转换，要用L标识
    wchar_t *p1 = L"JS你这个凑标志";
    // wcout用来输出宽字符
    wcout << p1 << endl;
    return 0;
}
```

#### 函数包装器

函数包装器是C++11的新语法，它就像字面意思一样，可以将**函数放到包装器函数里，在包装器函数中处理额外逻辑**。其实从功能上来说就是方便我们把函数作为参数传入到另一个函数里。它的本质还是函数指针。

因为要把函数作为参数传入，所以用函数模板能省去我们声明函数指针的繁琐过程，还能提升通用性。另外这里的**`[外部参数列表](函数参数列表){函数体}`其实是`lambda`表达式**。

这里还有个C++11的新语法：`using std::function`，表示只单独引用`function`。

函数包装器可以有下面几种作用：

1. 实现**函数拦截**（根据条件是否满足决定是否执行）、**调用计数**。
2. 实现**函数嵌套**。
3. 利用**模板函数**实现**通用泛型**。
4. **管理外部函数**（直接赋值，**代替函数指针**）。

```cpp
#include <iostream>
// 要使用函数包装器得使用这个头文件
#include <functional>
using namespace std;

// 声明包装器，第二个类型就是函数
template<typename T, typename F>
T wrapper(T i, F fun) {
    cout << "enhanced" << endl;
	return fun(i);
}

int mut(int i) {
    return i * 2;
}

int main() {
    // C++11的新语法，可以只引用单独的命名空间
    using std::cin;
    using std::function;
    
	// 包装器语法:
	// function<返回值(参数列表) = [](参数列表) { //函数体 };
	function<int(int)> func = [](int i) {
		return i * 2;
	// 注意这实际上是个表达式，所以末尾也得加分号	
	};
    
    // 这里可以直接把函数赋值，说明它实际上就是个函数指针
    function<int(int)> func2 = mut;
	
    // 单独调用
	cout << func(10) << endl;
    
    // 使用包装器加强
    cout << wrapper(10, func) << endl;;
	
	return 0;
}
```

#### CPP类型转换

##### 隐式显式类型转换

和C语言一样，C++也有隐式转换和显示转换。一般而**言隐式转换会发生在传参、构造初始化时**；而**显示转换就是赋值时通过`()`强制转换**。区分它们的最好方式就是**看有没有类型标识符**。

```cpp
// 隐式转换
int num(10.8);

// 显式转换
int t = (float)11.4;

class demo {
    public:
    	explicit demo(int n) {
            cout << n << endl;
        }
}

// 显式转换，这里可以通过强转的方式满足explicit
demo d = (demo)10;
// 报错，不满足explicit
demo t = 10;
```

##### 基本数据类型转换

我们前面提到的`const_cast`可以把`const`类型转为非`const`类型，但像指针之类的变量还是没法修改地址。而`static_cast`，则是用来**强制类型转换**的。它的作用和C的`(int)`这种是相同的。

`reinterpret_cast`可以**转换内存中不同类型的指针数据**，一般可用`static_cast`代替。

`dynamic_cast`则可进行**父类子类（对象间的）的数据类型转换**。

```cpp
const int *p = 20;

int *pt = const_cast<int *>(p);

// 不行，类型不同
const int *i = malloc(int);

// 可以，相当于把void *转为了 int *
const int *j = static_cast<int *>(malloc(int));

int *k = 123;
// 用来转换指针指向地址的数据类型
char *t = reinterpret_cast<char *>(&k);
```

##### 自定义类类型转换

C++中类**类型的转换**主要是**通过操作符重载完成**的。区别于`+-*/`之类的操作符，这里重载的**操作符为要转换的类型**，**不能有参数，不能作为友元函数**，必须要**返回对应类型的结果**。

```cpp
#include <iostream>
using namespace std;

class demo {
	private:
		int n;
	public:
		explicit demo(int n) {
			this->n = n;
		}
		
    	// 发生int类型转换时，把类的值当成n
		operator int() {
			return n;
		}
};

// 不支持友元
friend operator float() {
    
}


int main() {
	demo d = (demo)10;

	int t = d;
	cout << t << endl;
	return 0;
}
```

#### 高级数组

##### array数组

###### 基本使用

`array`是C++中提供的一种高级数组，它的**作用和普通数组是基本类似的，但可进行数组间整体操作，且适用于任何类型**，用起来更加方便。这里我们要区分`vector`，**`array`没有提供变长之类的方法**。

而且**`array`是一个放在栈上的静态数组**（`vector`是放在堆上的动态数组），这意味着我们**分配空间过多时会产生栈溢出**。

**`array`在初始化类实例数组**时比C风格数组好用很多，所以更多**用于复杂类型数组**。

```cpp
#include <iostream>
// 要引入这个头文件
#include <array>
#include <string>

using namespace std;

int main() {
    // 初始化一个长度为4的int类型数组
    array<int, 4> arr1 = {1, 2, 3, 4};
    array<string, 3> arr2 = {"hello", "hello", "how low"};
	// 二维数组（2行4列）
    array<array<int, 4>, 2> arr3 = { arr1, arr1 };
    
    // array提供了swap方法，可以直接把两个数组内容互换
    arr1.swap(arr2);
    
    // 系统默认栈大小1M，分配8M内存，爆栈
    array<double, 1024 * 1023> db;
    return 0;
}
```

###### 迭代器遍历

和`vector`类似，`array`也提供了**迭代器**接口：

```cpp
#include <iostream>
#include <array>

using namespace std;

int main() {
	array<int, 5> arr = {1, 2, 3, 4, 5};
	
	for (array<int, 5>::iterator it = arr.begin(); it != arr.end(); ++it) {
		cout << *it << ' ' << endl;
	}
	
    // 反向迭代
    array<int, 5>::reverse_iterator cbegin, cend;
	cbegin = arr.rbegin();
	cend = arr.rend();
	
	while (cbegin != cend) {
		cout << *cbegin << endl;
		++cbegin;
	}
    
	return 0;
}
```

###### foreach和lambda遍历

C++中提供了`for_each`函数（包含在`algorithm`头文件里），它**可以遍历迭代器范围内的数据**，和JS类似，它也是通过一个回调函数处理，为了方便，我们可以使用**`lambda`函数**。

```cpp
#include <iostream>
#include <array>
// for_each头文件
#include <algorithm>

using namespace std;

int main() {
	array<int, 5> arr = {1, 2, 3, 4, 5};

    int res = 0;
	
    // 使用引用操作外部变量，res等价于返回值
	for_each(arr.begin(), arr.end(), [&res](int x){
		res += x;
	});
	
	cout << res << endl;
	
	return 0;
}
```

##### vector变长数组

这部分内容只是提到了，还没讲到，先留个位置...

似乎只是讲了各种方法的使用...

##### tuple元组

和`Python`中的类似，C++中的元组也是**不可变，可混用任意数据类型**的。

```cpp
tuple<int, char, char *> mytuple(1, 'A', "hello world");

// 使用get<下标>的方式取值
auto = std::get<0>(mytuple);
```

#### 仿函数（引用类内部函数)

仿函数是指**取出类或者结构体中公有成员函数，单独调用的函数**。要完成这个操作我们需要**使用`bind`函数**，实际上这个操作本质就是**用函数指针，取出类地址中的特定函数**。

`bind`函数的语法：`bind(&类/结构体::特定函数, &类/结构体实例, _1, _2, ...占位)`。这里的`&`是取地址，`_1/_2`是参数占位符，想要正确调用必须严格匹配。

`bind`包含在`functional`头文件中，`_1`占位符则需要从`std::placeholders`命名空间里取。

```cpp
#include <iostream>
#include <functional>
using namespace std;
using namespace std::placeholders;

struct demo {
	public:
		void say() {
			cout << "hello world" << endl;
		}
		
		int add(int a) {
			return a + 10;
		}
};

int main() {
	demo d1;
	
    // 注意是从实例里取，因为要访问当前实例的内部变量
	auto say = bind(&demo::say, &d1);
	say();
	
    // _1占位
	auto add = bind(&demo::add, &d1, _1);
	cout << add(10) << endl;
    
    // 可以这样去去内部函数的地址，所以本质还是函数指针
    int (demo::*t)(int) = &demo::add;
	auto t2 = &demo::add;

	return 0;
}
```

#### 智能指针

普通指针在指向一片内存后，就会一直引用，除非我们使用`delete`销毁。而智能指针就是可以**自动判断内存是否可释放，如果可以，就自动释放**。使用它可以优化程序内存占用。

智能指针分为C++98和C++11两种，C++98的语法是`auto_ptr<type> name(ptr);`（不知道为什么C++11里没有，注意**它不能直接`new`内存，只能间接指向内存指针**）。

这里还有其它两种智能指针，参考：[C++智能指针之shared_ptr与右值引用(详细))](https://www.cnblogs.com/wanghongyang/p/15003611.html)，因为教程还没提到所以先放着。

##### unique_ptr

它是一种独占的智能指针，也就是**一个指针管理一块内存**。语法是`std::unique_ptr<type> name(new type);`，它**包含在`memory`这个头文件里**。

```cpp
#include <iostream>
#include <memory>
using namespace std;


struct demo {
	public:
		void say() {
			cout << "hello world" << endl;
		}
		
		int add(int a) {
			return a + 10;
		}
};

int main() {
    // 可以直接new
	unique_ptr<int> pi(new int);

    int t = new int;
    // C++98智能指针只能间接引用
    auto_ptr<int > at(t);
	return 0;
}
```

#### 多线程

这里先简单看看怎么用。多线程在C++中是`thread`类，它包含在`std::this_thread`这个命名空间中。声明了一个多线程类，**并不会直接去调用这个多线程**，**得手动执行`join`才行**。

```cpp
#include <iostream>
#include<thread>
using namespace std;
using namespace std::this_thread;

void say_hello() {
	cout << "hello world" << endl;
}

int main() {
	thread t(say_hello), t2(say_hello);
	
	t.join();
	t2.join();

	return 0;
}
```

#### 不识别转义字符

一个小知识：使用**`R"()"`就能不识别转意字符**，这在访问路径之类的场景是比较有用的。

```cpp
string t = R"(C:\asdf)";
```

#### 类型别名

有时候我们希望定义一个类型在程序中多处使用，这时可以用**C的`typedef`**，也可用**C++的`using`**。另外**命名空间的别名也是可以用`using`的**。

```cpp
int add(int a, int b) {
    return a + b;
}

// add函数类型的别名
typedef int (*ADD)(int, int);

// C++风格的别名
using FUNC = int (*)(int, int);

namespace space {
    // 模板别名，模板类型 using 名称 = 类型;
    template<class T> using ptr = T*;
}

FUNC a = add;
a(1, 2);
```

#### 模板元编程

简单来说，**模板元编程就是把运行时耗时转移到编译时**。这在一些高复杂计算场景是非常有用的，例如递归。利用模板特化机制实现**编译期条件选择结构**，利用**递归模板实现编译期循环结构**，模板元程序则由编译器在编译期解释执行。

因为模板元是编译期就进行优化的，所以它**只能生成常量情况下的代码**（也就解释了为什么OI没有w）。

模板元的优点很明显，运行速度快：

1. 以编译耗时为代价换来卓越的运行期性能（一般用于为性能要求严格的数值计算换取更高的性能）。通常来说，一个有意义的程序的运行次数（或服役时间）总是远远超过编译次数（或编译时间）。

2. 提供编译期类型计算，通常这才是模板元编程大放异彩的地方。

模板元编程技术并非都是优点：

1. 代码可读性差，以类模板的方式描述算法也许有点抽象。

2. 调试困难，元程序执行于编译期，没有用于单步跟踪元程序执行的调试器（用于设置断点、察看数据等）。程序员可做的只能是等待编译过程失败，然后人工破译编译器倾泻到屏幕上的错误信息。

3. 编译时间长，通常带有模板元程序的程序生成的代码尺寸要比普通程序的大，

4. 可移植性较差，对于模板元编程使用的高级模板特性，不同的编译器的支持度不同。

下面来看一段用模板元实现斐波那契数列的程序：

```cpp
#include<iostream>

// 递归模板
template<int N>
struct data {
  	// 使用递归生成循环结构  
	enum a { res = data<N - 1>::a::res + data<N - 2>::a::res };
};

// 特殊模板，递归边界
template<>
struct data<1> {
	enum a {res = 1};
};

template<>
struct data<2> {
	enum a {res = 1 };
};

int getdata(int n) {
	if (n==1 || n==2) {
		return 1;
	} else {
		return getdata(n - 1) + getdata(n - 2);
	}
}

int main() {
	const int myint = 40;
    // 调用模板元
    // 可以用data<myint>::a::res访问，也可以像下面一样简写
	int num = data<myint>::res;//<>内部不可以有变量
	std::cout << num << std::endl;

	std::cout << getdata(40) << std::endl;

	std::cin.get();

	return 0;
}
```

#### 静态断言和常用宏

静态断言可以帮助我们**在编译期间就确定错误**，还可以**定义编译器报错提示**：

```cpp
// 要包含这个头文件
#include <assert.h>

char num = 10;
// 如果这里num是4个字节以上的变量，就报错
static_assert(sizeof(num) >= 4, "类型错误!")；
```

下面这些宏变量可以帮助我们快速定义错误位置：

```cpp
cout << __FILE__ << endl;
cout << __LINE__ << endl;
cout << __DATE__ << endl;
cout << __TIME__ << endl;
cout << __FUNCTION__ << endl;
```

#### union共用体

共用体和结构体和类是类似的，先来说说结构体的大小怎么算...结构体的大小并不是几个类型的变量所占字节之和，而是要**考虑字节对齐**的。直接看下面的例子：

```cpp
struct t {
    // 8
	double a;
    // 8
	double b;
    // 4
	int c;
    // 1，占不满4字节，填充为4
	char d;
};

// 8+8+4+4 = 24
sizeof(t); 
```

共用体具备结构体的所有功能，但它**同一时刻只允许一个变量存在，而且全部成员公有，不能更改，不能继承**。所以**它的大小就是内部占空间最大的变量的大小**，比较适用于需要节省内存的情况。

```cpp
union tt {
    double n;
    int i;
}

tt data;
data.i = 20;
// 20
cout << data.i << endl;

data.n = 10.0;

// 未定义的值，因为此时内存被n拿去用了
cout << data.i << endl;

// 8
sizeof(tt);
```

#### C和C++的空指针

C中空指针用`NULL`表示，它**本质上是数字`0`**。C++中空指针用`nullptr`表示，它**能满足我们强类型的需求**。观察下面的代码就能发现二者的区别了：

```cpp
void test(int * p) {
    cout << "num p" << endl;
}

void test(void * p) {
    cout << "void p" << endl;
}

// 调用的是int的，因为NULL就是0
test(NULL);
// 调用void的，因为nullptr能进行强类型检测
test(nullptr);
```

#### 静动态联编

这是一些概念性的知识。**联编指一个程序模板、代码间互相关联的过程**，它又分为静态联编和动态联编两种。

1. **静态联编**：是**程序的匹配、连接在编译阶段实现**，也称为早期匹配。一些常量、重载、`#define`条件表达式等都是静态联编时完成的。
2. 动态联编：是**程序联编推迟到运行时进行**，所以也称晚期联编。需要程序运行时动态生成的代码，比如`if/switch`等，就时动态联编时完成。